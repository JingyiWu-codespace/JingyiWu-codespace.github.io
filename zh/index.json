[{"content":" 🔗 Github: EmbeddedSystem_HeartRateMonitor_WebApplication\n","permalink":"https://jingyiwu-codespace.github.io/zh/projects/tech/hrm_sees/","summary":"硬件: PSOC 6 + MAX 30102 软件: Javascript + HTML + chart.js + Python Flask","title":"嵌入式系统｜基于网页开发心率监测应用"},{"content":"暑假回家的碎碎念 从7月中旬到现在刚好差不多一个月，今天打开领英发现又是一年。\n总结来讲：更温和了，事情在我的眼里并不是非黑即白了。当时出来只为了向往自由，但是这次回家看到之前的同学们，都慢慢稳定下来，都在准备订婚与备婚的事情。再看看自己，是不是仅仅追求所谓的自由是不是有点胡闹了呢？\n关于父母：次回来发现 妈妈逐渐变老了，虽然她还是保持运动习惯，但是健康状况还是偶尔会被一些小问题影响。作为唯一的女儿又不在身边，我会觉得因为照顾不到她而愧疚。也经常在想做点什么才能让她开心呢？讲真对于我爸，并不担心，他的心态太独立，会给自己找乐子。\n感觉自己心智成熟了，也学会了慢下来，什么事情都告诉自己只有付出行动就会有变化，其余的交给时间。对外界的信号脱敏了很多，之前跟外人讲话都要紧张的攥拳头，现在慢慢变好了许多。确实什么事情都靠练习，在练习的过程中找到最适合自己的办法。慢慢的坚定自己，不卑不亢才能招架住成年人的世界。\n这一年坚持下来了，是一个挑战，给自己点一个小小的赞，未来可期。\n","permalink":"https://jingyiwu-codespace.github.io/zh/posts/life/summer_holiday_memo/","summary":"在比利时流浪一年，对我的影响和改变都有什么？","title":"ε≡٩(๑\u003e₃\u003c)۶"},{"content":"","permalink":"https://jingyiwu-codespace.github.io/zh/projects/tech/notepad/","summary":"持久化存储/多语言模式/增删任务/一键清空","title":"前端开发｜基于VUE简易记事本应用"},{"content":"Git 分布式代码版本控制系统，帮助开发团队维护代码。实现记录代码内容，切换代码版本，多人开发时高效合并代码内容\n安装及配置 1.如何判断安装成功？ 打开bash终端 (git专用) 命令：git-v 查看版本号 2. Git 配置用户信息 用户名git config --global user.name \u0026quot;用户名\u0026quot;\n邮箱 git config --global user.email \u0026quot;@gamil\u0026quot;\nGit 仓库 Git 仓库 (repository): 记录文件状态内容的地方，存储修改历史记录\n如何创建：\n把本地文件夹转换成Git仓库： git init 从其他服务器上克隆Git仓库 Git 三个区域 工作区：实际开发时操作的文件夹 暂存区：保存之前的准备区域（暂存改动的文件） .git/index 版本库： 提交并保存暂存去中的内容，产生一个版本快照 .git/objects 命令 作用 git add 文件名 暂存指定文件 git add . 暂存所有改动文件 git commit -m \u0026ldquo;注释说明\u0026rdquo; 提交并保存，产生版本快照 git ls-files 看看暂存区有啥文件 git status -s 查看文件状态，并最终提交 Git文件状态 未跟踪： 新文件，从未被Git管理过 已跟踪：Git已经知道和管理文件 使用： 修改文件-\u0026gt; 暂存-\u0026gt; 提交保存记录\n文件状态 概念 场景 未跟踪 (U) 从未被Git管理过 新文件 新添加 (A) 第一次被Git暂存 之前版本记录无此文件 未修改 (\u0026rsquo; \u0026lsquo;) 三个区域统一 提交保存后 已修改 (M) 工作区内容变化 修改了内容产生 git status -s\n第一列是暂存区的状态 第二列是工作区的状态 Git 暂存区使用 暂时存储，可以临时恢复代码内容，与版本库解藕\n暂存区 -\u0026gt; 覆盖 -\u0026gt; 工作区 git restore 目标文件 (注意：完全确认覆盖时使用) 从暂存区移除文件 git rm --cached 目标文件 Git 回退版本 把版本库某个版本对应的内容快照，恢复到工作区/暂存区\n查看提交历史 ： git log --oneline\n查看完整日志： git reflog --online\n回退命令： git reset \u0026ndash;soft 版本号 (其他文件未跟踪)\n会尽可能保留 暂存区和工作区 里面的内容，都会变为未被 git 跟踪的状态\n回退命令： git reset \u0026ndash;hard 版本号，只会看到回退的文件，其他全部删除\n回退命令： git reset \u0026ndash;mixed 版本号 (git reset 默认模式)，暂存区只会看到回退的文件， 但是工作区会保留\n总结：\n什么是Git回退版本？\n将版本库某个版本对应的内容快照，回复到工作区/暂存区\n强制覆盖暂存区和工作区命令？\ngit reset --hard 版本号\n如何查看提交历史\ngit log --oneline\ngit reflog --oneline\nGit 删除文件 方法一\n手动在工作区中删除 -\u0026gt; git add . 至暂存区 -\u0026gt; git commite -m\u0026quot;\u0026quot;\n方法二\n手动在工作区中删除 -\u0026gt; git rm --cached 目标文件 -\u0026gt; git commite -m\u0026quot;\u0026quot;\nGit 忽略文件 .gitignore 文件可以让 git 彻底忽略跟踪指定文件\n目的： 让git仓库更小更快，避免重复无意义的文件管理。\n系统或软件自动生成的文件 编译产生的结果文件 运行时生成的日志文件，缓存文件，临时文件 涉密文件，密码，秘钥等文件 创建步骤：\n项目__根目录__新建 .gitignore 文件 填入相应配置来忽略指定文件 # 忽略 npm 下载的第三方包 node_modules # 忽略分发 文件夹 dist # 忽略 VSCode 配置文件 .vscode # 忽略秘钥文件 *.pem *.cer # 忽略日志文件 *.log Git 分支 本质是 指向提交节点的可变指针， 默认名字是master/main\n注意： HEAD指针影响工作区/暂存区的代码状态\n场景 开发新需求/修复Bug，保证主线代码随时可用，多人协助 保证主线业务的同时，新增content分支，继续增加新功能，但不影响主分支master的功能 在新分支中修复bug 步骤\u0026amp;命令 创建分支 git branch 分支名\n切换分支 git checkout 分支名\n查看分支 git branch\n就是将 HEAD 指针指向 新的分支\n总结：\n什么是Git分支？\n指针，指向提交记录\nHEAD 指针的作用？\n影响暂存区和工作区的代码\n如何创建和切换指针？\ngit branch 分支名\ngit checkout 分支名\nGit 分支 - 合并与删除 把分支合并回`master，并删除分支\n切换回要合入的分支，如果要合并至master: git checkout master git merge 要合并的分支 删除合并后的分支指针： git branch -d 已合并的分支 Git 分支 - 合并与提交 发生于原分支产生了新的提交记录后，再合并回去时发生，自动使用多个快照记录合并后产生一次新的提交\n切回到要合入的分支 git checkout master 合并其他分支 git merge content 删除合并后的分支 git branch -d content Git 分支 - 合并冲突 在不同的分支中，对同一个文件的同一部分修改，Git无法干净的合并，产生合并冲突\n打开VSCode找到冲突文件并手动解决 解决后需要提交暂存，再次提交一次至版本库 删除合并后的分支 Git 常用命令总结 命令 作用 注意 git -v 查看git版本 git init 初始化git仓库 git add \u0026lsquo;文件标识\u0026rsquo; 暂存某个文件 文件标识以终端为起始的相对路径 git add . 暂存所有文件 git commit -m \u0026lsquo;\u0026hellip;\u0026rsquo; 提交产生版本记录 每次提供，把暂存区内容快照一份 git status 查看文件状态 - 详细信息 git status -s 查看文件状态 - 简略信息 第一列是暂存区状态，第二列是工作区状态 git ls-files 查看暂存区文件列表 git restore \u0026lsquo;文件标识\u0026rsquo; 从暂存区恢复到工作区 如果文件标识为，则恢复所有文件 git rm \u0026ndash;cached 从暂存区移除文件 不让git跟踪文件变化 git log 查看提交记录- 详细 git log \u0026ndash;oneline 查看提交记录- 简略信息 版本号 分支指针 提交时说明注释 git relog \u0026ndash;oneline 查看完整历史 -简略消息 包括提交，切换，回退等所有记录 git reset 版本号 切换版本代码到暂存区和工作区 git branch 分支名 创建分支 git branch 查看本地分支 git branch -d 分支名 删除分支 确保记录已经合并到别的分支下，再删除分支 git checkout 分支名 切换分支 git checkout -b 分支名 创建并立刻切换分支 git merge 分支名 把分支提交历史记录合并到当前所在分支 Git 远程仓库 托管在网络中的项目版本库\n作用： 保存版本库的历史记录，多人协作\n创建： 公司自己的服务器/第三方托管平台 (Github)\n推送步骤 注册第三方平台账号(创建repo)\n新建仓库得到远程仓库 Git 地址\n本地 Git 仓库添加远程仓库原点地址\ngit remote add origin 仓库地址\n本地Git 仓库推送版本记录到远程残酷\ngit push -u 远程仓库别名 本地和远程分支名\ngit push -u origin master\n完整写法 git push --set-upstream origin master:master\n如果添加错了远程仓库，如何移除？\ngit remote remove origin\n克隆 clone 命令： git clone 'url' 会在运行命令的文件夹生成项目文件夹（包含版本库，并映射到暂存区和工作区） 注意：\nGit本地仓库已经建立好和远程仓库的连接，再次推送无需push 更新本地代码 pull 1.多人协同工作步骤\nA 开发代码 -\u0026gt; 工作区 -\u0026gt; 暂存区 -\u0026gt; 提交 -\u0026gt; 拉取 (可选) -\u0026gt; 推送 B -\u0026gt; 拉取（后续也可以开发代码 -\u0026gt; \u0026hellip; -\u0026gt; 推送） 2.命令\ngit pull 远程仓库别名 本地和远程分支名 git pull origin/maste\ngit pull rebase prigin master 强制合并\nGit 远程仓库常用命令 命令 作用 注意 git remote add 远程仓库别名 远程仓库地址 添加远程仓库地址 别名唯一 git remote -v 查看远程仓库地址 git remote remove 远程仓库别名 删除远程仓库地址 git pull 远程仓库别名 远程仓库地址 拉去 等于 git fetch + git merge git push 推送 git pull \u0026ndash;rebase 远程仓库别名 分支名 拉取合并 合并没有关系的记录 git clone 远程仓库地址 克隆 ","permalink":"https://jingyiwu-codespace.github.io/zh/posts/tech/git/","summary":"Git basic operation","title":"学习：Git "},{"content":" 最近比较沉迷mermaid感觉简单干净又好看, 用mermaid展现一下\ngantt title Vue Learning Process dateFormat M-D axisFormat %m-%d section Vue Vue 2:active, 2024-04-05, 5d Vue Project:, 2024-04-10, 3d Vue 3: 2024-04-14, 7d Day1\u0026amp;2 Vue 快速上手 1. Vue 概念 是一个用于构建用户界面的渐进式框架\n1: 构建用户界面 指的是 基于数据渲染出用户看到\n2: 循序渐进： 声明式渲染 - Vue.js 核心包 - 组件系统 - 客户端路由 (VueRouter) - 大规模状态管理(Vuex) - 构建工具(Webpack/Vite)\n3: 框架：一套完整的项目解决方案\nVue 的两种使用方式：\nVue 核心包开发\n场景：局部模块改造\nVue 核心包 \u0026amp; Vue 插件 工程化开发\n场景：整站开发\n2. 创建Vue实例，初始化渲染 构建用户界面 -\u0026gt; 创建Vue实例初始化渲染\ngraph LR; 构建用户界面--\u003e创建Vue实例初始化渲染; 创建Vue实例初始化渲染--\u003eID1[1.准备容器]; 创建Vue实例初始化渲染--\u003eID2[2.官网引包dev production]; 创建Vue实例初始化渲染--\u003eID3[3.创建Vue实例]; 创建Vue实例初始化渲染--\u003eID4[4.指定配置项]; ID4 --\u003e el指定挂载点 ID4 --\u003e data提供数据 代码案例：\n\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; {{ msg }} \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;url.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const app = new Vue({ // 通过el配置选择器，指定Vue管理的盒子 el: \u0026#39;#app\u0026#39;, // 通过data提供数据 data:{ msg:\u0026#39;Hello World\u0026#39; // 变量提供数据 } }) \u0026lt;/script\u0026gt; 总结 创建Vue实例，初始化渲染的核心步骤\n准备容器\n引包 (官网) -开发版本/生产版本\n创建Vue实例 new Vue()\n指定配置项 el data 渲染数据\nel 指定挂载点，选择器指定控制盒子\ndata 提供数据\n3. Vue 插值表达式 插值表达式是一种Vue的模版语法 {{ }}\n作用：利用表达式进行插值，渲染到页面中\n表达式：JS引擎将其返回结果的代码\nmoney + 100 money - 100 money * 10 money / 10 price \u0026gt;= 100? \u0026#39;greater\u0026#39;:\u0026#39;ok\u0026#39; obj.name arr[0] fn() obj.fn() 语法 ： {{ 表达式 }} \u0026lt;h3\u0026gt;{{ title }}\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;{{ nickname.toUpperCase() }}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;{{ age\u0026gt;=18 ? \u0026#39;成年\u0026#39;:\u0026#39;未成年\u0026#39; }}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;{{ obj.name }}\u0026lt;/p\u0026gt; 注意事项\n使用的数据必须在data内声明\n支持表达式，但不支持语句，所以可以写三元表达式，但不能写 if for\n不能在标签属性中使用 {{ }} 插值\n\u0026lt;p title = \u0026quot;{{ username }}\u0026quot;\u0026gt;这里可以使用插值 \u0026lt;/p\u0026gt; 总结\n插值表达式的作用？\n利用表达式进行插值，将数据渲染到页面中\n语法格式？\n{{ 表达式 }}\n插值表达式的注意点\n使用的数据要存在\n支持表达式，而不是语句\n不能在标签属性中使用\n4. Vue响应式特性 数据变化，视图自动更新\ndata 中的数据会被添加到实例上\n访问数据: 实例.属性名 app.msg 修改数据: 实例.属性名 = value app.msg = '您好 Vue' \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; {{ msg }} \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;url.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const app = new Vue({ // 通过el配置选择器，指定Vue管理的盒子 el: \u0026#39;#app\u0026#39;, // 通过data提供数据 data:{ msg:\u0026#39;Hello World\u0026#39; // 变量提供数据 count:100 } }) \u0026lt;/script\u0026gt; 5. 开发者工具 Devtools 6. Vue 指令 Vue 会根据不同的 【指令】，针对标签实现不同的【功能】\n指令： 带有 v-的特殊标签属性，大约14个，常用10个，文档可查\nv-html 示例代码：\n\u0026lt;!-- Vue指令： v- 前缀的标签属性 作用：设置元素的innerHTML 语法：v-html= ‘表达式’ 可以解析html标签，如果使用插值表达式的话标签会变成文本 --\u0026gt; \u0026lt;div v-html = \u0026#39;str\u0026#39;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!-- 普通标签属性 --\u0026gt; \u0026lt;div class = \u0026#34;box\u0026#34;\u0026gt;...\u0026lt;/div\u0026gt; \u0026lt;div title = \u0026#34;校长\u0026#34;\u0026gt; ...\u0026lt;/div\u0026gt; v-show 作用：控制元素显示隐藏 语法：v-show ='表达式'，表达式值为true显示，false隐藏 底层原理：核心是控制元素的css属性，控制属性是否显示style = \u0026quot;display:none\u0026quot; 场景：频繁切换显示隐藏的场景 v-if 作用：控制元素显示隐藏（条件渲染） 语法：v-if ='表达式'，表达式值为true显示，false隐藏 底层原理：核心是根据判断条件控制元素的创建和移除。一旦为false，对应标签会消失 场景：要么显示，要么隐藏，不频繁切换的场景 \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;div v-show=\u0026#34;flag\u0026#34; class=\u0026#34;box\u0026#34;\u0026gt;我是v-show控制的盒子\u0026lt;/div\u0026gt; \u0026lt;div v-if=\u0026#34;flag\u0026#34; class=\u0026#34;box\u0026#34;\u0026gt;我是v-if控制的盒子\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;./vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const app = new Vue({ el: \u0026#39;#app\u0026#39;, data: { flag: true } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; v-else \u0026amp; v-else-if 作用：辅助 v-if 进行判断渲染 语法：v-else v-else-if = \u0026quot;表达式\u0026quot; 注意：需要紧挨着 v-if一起使用 \u0026lt;div id = \u0026#34;app\u0026#34;\u0026gt; \u0026lt;p v-if=\u0026#34;gender === 1\u0026#34;\u0026gt; 性别： 男\u0026lt;/p\u0026gt; \u0026lt;p v-if=\u0026#34;gender === 2\u0026#34;\u0026gt; 性别： 女\u0026lt;/p\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;p v-if= \u0026#34;score \u0026gt;= 90\u0026#34;\u0026gt;成绩A\u0026lt;/p\u0026gt; \u0026lt;p v-else-if= \u0026#34;score \u0026gt;= 70\u0026#34;\u0026gt;成绩B\u0026lt;/p\u0026gt; \u0026lt;p v-else-if= \u0026#34;score \u0026gt;= 60\u0026#34;\u0026gt;成绩C\u0026lt;/p\u0026gt; \u0026lt;p v-else \u0026gt;= 90\u0026#34;\u0026gt;成绩D\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; v-on 作用：注册事件 = 添加监听 + 提供处理逻辑\n语法：\nv-on: 事件名 = “内联语句”\nv-on: 事件名 = “method中的函数名”\nv-on： 事件名 = “method2(参数1，参数2)” v-on调用传递参数\n简写：@事件名\n\u0026lt;!-- 内联语句版本 --\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;!-- v-on: 可以简写替换为@ --\u0026gt; \u0026lt;button v-on:click=\u0026#34;count--\u0026#34;\u0026gt;-\u0026lt;/button\u0026gt; \u0026lt;span\u0026gt;{{ count }}\u0026lt;/span\u0026gt; \u0026lt;button @click=\u0026#34;count++\u0026#34;\u0026gt;+\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;./vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const app = new Vue({ el: \u0026#39;#app\u0026#39;, data: { count: 10 } }) \u0026lt;/script\u0026gt; \u0026lt;!-- method配置项内的函数名 --\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;!-- v-on: 可以简写替换为@ --\u0026gt; \u0026lt;button @click=\u0026#34;fn\u0026#34;\u0026gt;切换显示隐藏\u0026lt;/button\u0026gt; \u0026lt;h1 v-show=\u0026#34;isShow\u0026#34;\u0026gt;黑马程序员\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;./vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const app = new Vue({ el: \u0026#39;#app\u0026#39;, data: { isShow: true }, methods: { fn() { // this === app, 不能直接使用属性，会报错需要app.属性名 转换至 this.属性名 this.isShow = !this.isShow } fn2(a,b){ console.log(a,b) } } }) \u0026lt;/script\u0026gt; \u0026lt;!--调用传参数版本 --\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;小黑自动售货机\u0026lt;/h3\u0026gt; \u0026lt;button @click=\u0026#34;buy(5)\u0026#34;\u0026gt;可乐5元\u0026lt;/button\u0026gt; \u0026lt;!-- \u0026lt;button @click=\u0026#34;buyCoffee\u0026#34;\u0026gt;咖啡10元\u0026lt;/button\u0026gt; --\u0026gt; \u0026lt;button @click=\u0026#34;buy(10)\u0026#34;\u0026gt;咖啡10元\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;p\u0026gt;银行卡余额：{{ balance }}元\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;./vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const app = new Vue({ el: \u0026#39;#app\u0026#39;, data: { cola: 5, coffee: 10, balance: 1000 }, methods: { buy(a) { this.balance -= +a } } }) \u0026lt;/script\u0026gt; v-bind 作用：动态设置 html 的标签属性 —\u0026gt; src url title \u0026hellip;..\n语法：v-bind : 属性名=“表达式”\n属性名中不能使用插值表达式\n简写版 ：src\n传统版本 \u0026lt;img v-bind:src=\u0026quot;imgUrl\u0026quot;\u0026gt;\n简写版本 \u0026lt;img :src=\u0026quot;imgUrl\u0026quot; :title=\u0026quot;msg\u0026quot;\u0026gt;\nv-bind 对于样式控制的增强 操作 class\n语法： class = \u0026ldquo;对象\u0026rdquo;\n对象 -\u0026gt; 键就是类名，值是布尔值。如果值为true，有这个类，否则没有这个类 \u0026lt;div class = \u0026quot;box\u0026quot; :class = \u0026quot;{类名1: 布尔值， 类名2:布尔值}\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;\n数组 -\u0026gt; 数组中所有的类，都会添加到盒子上，本质是class列表 \u0026lt;div class=\u0026quot;box\u0026quot; :class\u0026quot;[类名1， 类名2， 类名3]\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;\n\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;!---使用 :class 对象 绑定 类名--\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34; :class=\u0026#34;{pink:true,big:true}\u0026#34;\u0026gt;黑马程序员\u0026lt;/div\u0026gt; \u0026lt;!---使用 :class 列表 绑定 类名--\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34; :class=\u0026#34;[\u0026#39;pink\u0026#39;,\u0026#39;big\u0026#39;]\u0026#34;\u0026gt;黑马程序员\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const app = new Vue({ el: \u0026#39;#app\u0026#39;, data: { } }) \u0026lt;/script\u0026gt; 操作 style -\u0026gt; 方便控制单个属性的变化\n语法： :style = \u0026quot;样式对象\u0026quot;\n\u0026lt;div class = \u0026quot;box\u0026quot; :style=\u0026quot;{css属性名1:css属性值，css属性名2:css属性值}\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;\n\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;!---使用 :style 对象 绑定 样式--\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34; :style=\u0026#34;{width:\u0026#39;400px\u0026#39;,height:\u0026#39;200px\u0026#39;,backgroundColor = \u0026#39;green\u0026#39;}\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const app = new Vue({ el: \u0026#39;#app\u0026#39;, data: { } }) \u0026lt;/script\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;progress\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;inner\u0026#34; :style=\u0026#34;{width:percent + \u0026#39;%\u0026#39;}\u0026#34;\u0026gt; \u0026lt;span\u0026gt;{{percent}}%\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;button @click=\u0026#34;percent = 25\u0026#34;\u0026gt;设置25%\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;percent = 50\u0026#34;\u0026gt;设置50%\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;percent = 75\u0026#34;\u0026gt;设置75%\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;percent = 100\u0026#34;\u0026gt;设置100%\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const app = new Vue({ el: \u0026#39;#app\u0026#39;, data: { percent: 0 } }) \u0026lt;/script\u0026gt; v-for 作用：基于数据循环，多次渲染整个元素 -\u0026gt; 数组、对象、数字\u0026hellip;\n遍历数组语法：\nv-for = \u0026quot;(item,index) in 数组\u0026quot;\nitem 指的是每一项， index 指的是下标\nv-for 中的 key\nkey =“唯一标识”\n作用： 给列表项添加的唯一标识。便于Vue进行列表项的正确排序复用\n注意点：\nkey 的值只能是字符串或数字类型 key的值必须具有唯一性 推荐使用 id 作为 key (唯一)，不推荐使用 index 作为 key （会变化，不对应） \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;小黑水果店\u0026lt;/h3\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;(item,index) in list\u0026#34; ：key=\u0026#34;item-id\u0026#34;\u0026gt;{{item}} - {{index}}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;./vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const app = new Vue({ el: \u0026#39;#app\u0026#39;, data: { list: [\u0026#39;西瓜\u0026#39;, \u0026#39;苹果\u0026#39;, \u0026#39;鸭梨\u0026#39;] } }) \u0026lt;/script\u0026gt; 补充知识： 列表.filter()\n一个列表方法，具体和map/reduce差不多, 默认返回新值不改变原数组，所以记得找变量接收 v-model 作用：给表单元素使用，双向数据绑定 -\u0026gt; 可以快速获取或设置表单元素内容 数据变化 -\u0026gt; 视图自动更新 视图变化 -\u0026gt; 数据自动更新 语法： v-model = \u0026lsquo;变量\u0026rsquo; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; 账户：\u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;username\u0026#34;\u0026gt; \u0026lt;br\u0026gt;\u0026lt;br\u0026gt; 密码：\u0026lt;input type=\u0026#34;password\u0026#34; v-model=\u0026#34;password\u0026#34;\u0026gt; \u0026lt;br\u0026gt;\u0026lt;br\u0026gt; \u0026lt;button @click=\u0026#34;login\u0026#34;\u0026gt;登录\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;reset\u0026#34;\u0026gt;重置\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;./vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const app = new Vue({ el: \u0026#39;#app\u0026#39;, data: { username: \u0026#39;\u0026#39;, password: \u0026#39;\u0026#39; }, methods: { login() { console.log(this.username, this.password) }, reset() { this.username = \u0026#39;\u0026#39;, this.password = \u0026#39;\u0026#39; } } }) \u0026lt;/script\u0026gt;\tv-model 应用于其他表单元素\n常见的表单元素都可以用 v-model绑定关联，快速获取或设置表单元素的值，它会根据控件类型自动选取正确的方法来更新元素\n表单类型 值 输入框 input:text value 文本域 textarea value 复选框 input:checkbox checked 单选框 input:radio checked 下拉菜单 select value 7. 指令修饰符 通过 “ . ” 指明一些指令 后缀，不同后缀封装了不同的处理操作 —\u0026gt; 简化操作\n按键修饰符\n@keyup.enter —\u0026gt; 键盘回车监听\nv-model 修饰符\nv-model.trim —\u0026gt; 去除首尾空格\nv-model.number –\u0026gt; 转数字\n事件修饰符\n@事件名.stop —\u0026gt; 阻止冒泡\n@事件名.prevent —\u0026gt; 阻止默认行为\n8. 计算属性 基于现有的数据，计算出新的属性。依赖的数据变化，自动重新计算\n语法：\n声明在 computed 配置项中，一个计算属性对应一个函数。computed 与 data 同级 使用起来和普通属性一样使用 {{ 计算属性名 }} 计算属性 -\u0026gt; 就是将求值还输封装 注意：使用计算属性时不用加小括号，会导致报错\ncomputed :{ 计算属性名(){ 基于现有数据，编写求值逻辑 return 结果 } } 缓存特性(提升性能)\n计算属性会对计算出来的结果缓存，再次使用直接读取缓存，依赖项变化了，会自动重新计算 -\u0026gt; 并再次缓存 与 methods方法对比：\n作用：methods给实例提供一个方法，调用以处理业务逻辑\n语法：写在methods配置项中\n作为方法，需要调用 -\u0026gt; this.方法名() {{ 方法名() }} @事件名=“方法名”\n计算属性的修改：\n计算属性默认的简写，只能读取访问，不能修改。如果要修改需要写计算属性的完整写法 \u0026lt;!--简写版本--\u0026gt; computed: { 计算属性名(){ 一段代码逻辑(计算逻辑) return 结果 } } \u0026lt;!--完整版本--\u0026gt; computed: { 计算属性名{ \u0026lt;!--get--\u0026gt; get(){ 一段代码逻辑(计算逻辑) return 结果 }, \u0026lt;!--set--\u0026gt; set(修改的值){ 一段代码逻辑 (修改逻辑) } } } 9. watch 侦听器（监听器） 简写： 作用： 监视数据变化，执行一些业务逻辑或异步操作 语法： 简单写法： 简单类型数据，直接监视 完整写法： 添加额外配置项 data: { words:\u0026#39;苹果\u0026#39;, obj:{ word: \u0026#39;苹果\u0026#39; } }， watch: { \u0026lt;!-- 该方法会在数据变化时触发执行 newValue 新值 oldValue老值 (一般不用)， 所以有时只写newValue一个参数 --\u0026gt; 数据属性名 (newValue, oldValue){ 一些逻辑 // 异步操作 }, \u0026lt;!-- 对象里面的子属性记得加 引号 --\u0026gt; \u0026#39;对象.属性名\u0026#39;(newValue,oldValue){ 一些逻辑 // 异步操作 } } 完整写法：添加额外配置项 deep: true 对复杂类型深度监视，任何对象的修改都可以监视到，handle是执行的方法 immediate: true 初始化立刻执行一次 handler 方法。 \u0026lt;script\u0026gt; watch: { fruitList: { deep: true, immediate: true, \u0026lt;!--将变化后的newValue存入本地--\u0026gt; handler(newValue) { console.log(newValue) localStorage.setItem(\u0026#39;list\u0026#39;, JSON.stringify(newValue)) } } } \u0026lt;/script\u0026gt; watch侦听器的语法有两种 简单写法： 监视简单类型的变化 完整写法：添加额外的配置项（深度监视复杂类型，立刻执行） 案例技术总结： 渲染功能： v-if/v-else v-for遍历 :class绑定样式 删除功能：点击传参 filter 过滤覆盖原数组 修改个数：点击传参 find 全选反选：计算属性computed 完整写法 get/set 统计选中的总价和总数量：计算属性computed reduce条件求和 持久化到本地：watch监视，localStorage ,JSON.stringify, JSON.parse Day3 生命周期 1. Vue 生命周期介绍 Vue生命周期： 一个Vue实例从创建到销毁的整个过程\n思考：什么时候发送初始化渲染请求？（越早越好）什么时候开始操作dom？ （至少dom渲染出来）\ngraph LR subgraph 阶段1: 创建 执行一次 A[\"new Vue() 数据响应式处理\" ] end subgraph 阶段2: 挂载 执行一次 A --\u003e B[\"挂载节点,渲染模版\"] end subgraph 阶段3: 更新 执行多次 B --\u003e C[\"数据修改，更新视图\"] end subgraph 阶段4: 销毁 执行一次 C --\u003e D[\"销 毁 实 例\"] end 2. Vue生命周期函数(钩子函数) Vue生命周期过程中，会自动运行一些函数，称为生命周期钩子，让开发者可以在特定阶段运行自己的代码。四个周期八个函数\nVue提供 vue实例.$destroy()方法卸载实例，通常在卸载阶段做性能优化，清楚一些小组件 大多数使用 created 和mounted 比较多 ![image-20240408132259592](/Users/jingyiwu/Library/Application Support/typora-user-images/image-20240408132259592.png)\n3. created 应用 created ： 在此阶段发送请求。因为响应式数据已经准备好了，可以发送初始化渲染请求。beforeCreated阶段还都没准备好\n\u0026lt;script\u0026gt; const app = new Vue({ el: #app, data: { list:[] }, \u0026lt;！-- 发送请求 --\u0026gt; async created(){ const res = await axios.get(\u0026#39;url\u0026#39;) console.log(res) } }) \u0026lt;/script\u0026gt; 4. mounted 应用 mounted: 模版渲染完成，开始操作DOM\n\u0026lt;script\u0026gt; const app = new Vue({ el: \u0026#39;#app\u0026#39;, data:{ words:\u0026#39;\u0026#39; }, // 核心思路 // 1. 等输入框渲染出来 // 2. 让输入框获取焦点 mounted (){ // 给输入框焦点 document.querySelector(\u0026#39;#inp\u0026#39;).focus } }) \u0026lt;/script\u0026gt; 工程化开发 \u0026amp; 脚手架 Vue CLI 1. 引入 开发Vue的两种方式：\n核心包传统开发模式： 基于html/css/js 文件，直接引入核心包，开发Vue。 工程获开发模式：基于构建工具（例如：webpack）的环境开发Vue 问题: CLI 脚手架解决的问题，生成标准化配置\nwebpack配置不简单 雷同的基础配置 缺乏统一标准 graph LR A[源代码] --\u003e B[自动化编译压缩组合] B --\u003e C[运行代码] style B fill:#f9f,stroke:#333,stroke-width:4px 2. 介绍脚手架Vue CLI Vue CLI 是Vue官方提供的基于node的一个全局命令工具\n通过Vue CLI 可以帮助我们快速创建一个开发Vue项目的标准化基础架子。集成了webpack\n优点:\n开箱即用，零配置 内置 babel等工具 标准化 使用步骤：\n全局安装 (一次) yarn global add@vue/cli 或 npm i @vue/cli -g 查看Vue版本 vue --version 创建项目架子（项目名称不能使用中文）vue create project-name 启动项目：yarn serve 或 npm run serve (可以在 package.json的script中配置的) 3.脚手架目录文件介绍 \u0026amp; 项目运行流程 ![image-20240408183322494](/Users/jingyiwu/Library/Application Support/typora-user-images/image-20240408183322494.png)\ngraph TD A[yarn serve]--\u003e B[main.js] C[App.vue] --\u003e B B --\u003e D[index.html] 1. public/index.html 讲解 \u0026lt;body\u0026gt; \u0026lt;noscript\u0026gt; \u0026lt;!--给不支持js浏览器使用的--\u0026gt; \u0026lt;strong\u0026gt;We\u0026#39;re sorry but \u0026lt;%= htmlWebpackPlugin.options.title %\u0026gt; doesn\u0026#39;t work properly without JavaScript enabled. Please enable it to continue.\u0026lt;/strong\u0026gt; \u0026lt;/noscript\u0026gt; \u0026lt;!--Vue 所管理的容器，将来创建结构动态渲染--\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!--工程化开发模式中：这里不再编写代码，在App.vue编写--\u0026gt; \u0026lt;!-- built files will be auto injected --\u0026gt; \u0026lt;/body\u0026gt; 2.main.js 讲解 // 文件核心作用：导入App.vue，基于App.vue创建构造渲染 index.html // 1. 导入 Vue 核心包 import Vue from \u0026#39;vue\u0026#39; // 2. 导入 App.vue 根组件 import App from \u0026#39;./App.vue\u0026#39; // 提示：当前处于什么环境 （生产化境/开发环境） Vue.config.productionTip = false // 3. Vue实例化，提供render方法 -\u0026gt; 基于App.vue创建结构渲染 index.html. 此版本为简写版，写一个原始版本看看那 new Vue({ render: h =\u0026gt; h(App), }).$mount(\u0026#39;#app\u0026#39;) new Vue({ el:\u0026#39;#app\u0026#39;, // 作用：和$mount(\u0026#39;#app\u0026#39;)作用一致，用于指定Vue所管理容器 // render: h=\u0026gt;h(App), render:(createElement)=\u0026gt;{ // 基于App创建元素结构 return createElement(App) } }) 本质上： 基于App.vue创建结构，最终渲染index.html中 id=app的盒子\n3. App.vue 组件化开发\u0026amp;根组件 1. 组件化开发\u0026amp;根组件 组件化：一个页面可以拆分成一个个组件，每个组件都有自己的独立结构、样式、行为\n好处： 便于维护，利于复用 \u0026ndash;\u0026gt; 提升开发效率\n组件分类：普通组件、根组件\n根组件：整个应用最上层的组件，包裹所有普通的小组件\n![image-20240408194719480](/Users/jingyiwu/Library/Application Support/typora-user-images/image-20240408194719480.png)\ngraph TD A[App根组件] --\u003e B[头部组件] A[App根组件] --\u003e C[导航组件] A[App根组件] --\u003e D[主体组件] A[App根组件] --\u003e E[底部组件] D[App根组件] --\u003e F[商品组件] D[App根组件] --\u003e G[商品组件] 2.App.vue 三部分组成：\ntemplate: 结构（有且只有一个根元素 Vue2） script：js逻辑 style：样式（可支持less，需要装包） 让组件支持 less\nstyle标签，lang=\u0026quot;less\u0026quot;开启less功能 装包：npm add less less-loader \u0026lt;!--结构组件--\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;img alt=\u0026#34;Vue logo\u0026#34; src=\u0026#34;./assets/logo.png\u0026#34;\u0026gt; \u0026lt;img alt=\u0026#34;Vue logo\u0026#34; src=\u0026#34;./assets/logo.png\u0026#34;\u0026gt; \u0026lt;HelloWorld msg=\u0026#34;Welcome to Your Vue.js App\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;!--行为组件--\u0026gt; \u0026lt;!-- export导出当前组件JS配置项, 里面可以提供data/methods/computed/watch--\u0026gt; \u0026lt;script\u0026gt; import HelloWorld from \u0026#39;./components/HelloWorld.vue\u0026#39; export default { name: \u0026#39;App\u0026#39;, components: { HelloWorld } } \u0026lt;/script\u0026gt; \u0026lt;!--样式组件--\u0026gt; \u0026lt;style\u0026gt; #app { font-family: Avenir, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px; } \u0026lt;/style\u0026gt; 总结:\n组件化：\n页面可拆分成一个个组件，每个组件有独立的结构、样式、行为\n好处：便于维护，利于复用 -\u0026gt; 提升开发效率\n组件分类：普通组件、根组件\n根组件：\n整个应用最上层的组件，包裹所有普通小组件\n一个根组件App.vue 包含三个部分\ntemplate 结构 style 样式 script行为 4. 普通组件的注册使用 组件注册的两种方式：\n局部注册：只能在注册的组件内使用\n创建 .vue文件（三个组成部分） 在使用的组件内导入并注册 （一次可以注册多个组件） 全局注册：所有组件内都能使用\n与局部注册不同的是，局部注册在哪里注册在哪里使用。全局注册一旦注册成功，全局使用\n创建 .vue文件（三个组成部分） 在main.js中进行全局注册 （一次只能注册一个组件） 使用（全局/局部使用方法相同）：\n当成 html 标签使用 \u0026lt;组件名\u0026gt;\u0026lt;/组件名\u0026gt; 注意（全局/局部注意事项相同）：\n组件名规范-\u0026gt; 大驼峰命名法，HmHeader ![image-20240408200706235](/Users/jingyiwu/Library/Application Support/typora-user-images/image-20240408200706235.png)\n\u0026lt;!--局部注册 导入需要注册的组件 --\u0026gt; import 组件对象 from 路径 export default { // 局部组册 components:{ \u0026#39;组件名\u0026#39;：组件对象, } } \u0026lt;!--全局注册 导入需要注册的组件 --\u0026gt; import 组件对象 from 路径 \u0026lt;!--调用 Vue.component 进行全局注册 --\u0026gt; \u0026lt;!--Vue.component(\u0026#39;组件名\u0026#39;,‘组件对象’) --\u0026gt; Vue.component(\u0026#39;HmButton\u0026#39;,HmButton) Day4 1. 组件的三大组成部分 graph TD A[\"结构 Template\"] B[\"样式 style\"] C[\"逻辑 script\"] 结构 templates 只能有一个根元素\n样式 style 全局样式（默认），作用域全局影响所有组件。局部样式scoped只作用于当前组件\n\u0026lt;style scoped\u0026gt;\nscoped 的原理： 给当前组件模版的所有元素，都会被添加一个自定义属性data-v-hash ,利用hash值判定是否在组件范围内\nel 是根实例独有， data是一个函数，其他配置项一致\n一个组件的data选项必须是一个函数 -\u0026gt; 保证每个组件实例，维护独立的一份数据对象。每次创建新的组件实例，都会执行一次data函数，得到新的对象\n感觉老师的课件有点不说人话了，大致意思是，每一个data都会产生一个新的对象，这样在使用的时候（如修改数据）就不会影响到其他的模块\n2. 组件通信 组件通信，就是指组件与组件之间的数据传递\n组件的数据是独立的，无法直接访问其他的组件数据 想用其他组件数据 -\u0026gt; 组件通信 2.1组件关系分类 父子关系\n父传子的步骤：[使用 props]\n父组件内 给子组件标签添加属性方式，传值 子组件中通过props进行接收 子组件中渲染使用属性 \u0026lt;!-- 父组件的vue文件中 --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; 我是父组件 \u0026lt;!-- 1. 给组件标签，添加属性的方式，传值 --\u0026gt; \u0026lt;Son :title=\u0026#34;myTitle\u0026#34;\u0026gt;\u0026lt;/Son\u0026gt; \u0026lt;!--:title 动态属性，这样就可以将data中的myTitle传递给title属性了--\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import Son from \u0026#39;./component/Son.vue\u0026#39; export default { data(){ return { myTitle:\u0026#39;黑马程序员\u0026#39; } }, components:{ Son } } \u0026lt;/script\u0026gt; \u0026lt;!-- Son组件的vue文件中 --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div style=\u0026#34;border:3px\u0026#34;\u0026gt; \u0026lt;!-- 3. 渲染使用 title 属性 --\u0026gt; 我是Son组件 {{ mytitle }} \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default{ // 2. 通过 props进行接收 props: [\u0026#39;title\u0026#39;] } \u0026lt;/script\u0026gt; 子传父的步骤：[使用 emit]\n子组件methods内，$emit触发事件，给父组件发送消息通知 父组件内 监听事件 父组件提供处理函数，形参中获取参数 \u0026lt;!--父组件--\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;app\u0026#34; style=\u0026#34;border: 3px solid #000; margin: 10px\u0026#34;\u0026gt; 我是APP组件 \u0026lt;!--2. 父组件，对消息进行监听 @是v-on的缩写不要忘记了--\u0026gt; \u0026lt;Son :mytitle=\u0026#34;myTitle\u0026#34; @changeTitle = \u0026#34;handleChange\u0026#34;\u0026gt;\u0026lt;/Son\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import Son from \u0026#39;./components/Son.vue\u0026#39; export default { name:\u0026#39;APP\u0026#39;, data(){ return { myTitle:\u0026#39;今天发布了期末考试安排\u0026#39; } }, methods:{ handleChange(newTitle){ this.myTitle = newTitle } }, components:{ Son }, } \u0026lt;/script\u0026gt; \u0026lt;!--子组件--\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;son\u0026#34; style=\u0026#34;border:3px solid #000;margin:10px\u0026#34;\u0026gt; 我是Son组件 {{mytitle}} \u0026lt;button @click = \u0026#34;changeFn\u0026#34;\u0026gt;修改title\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default{ name: \u0026#39;Son\u0026#39;, props:[\u0026#39;mytitle\u0026#39;], methods:{ changeFn(){ // 1. 通过$emit，向父组件发送消息 this.$emit(\u0026#39;changeTitle\u0026#39;,\u0026#39;改名公式\u0026#39;) } } } \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; \u0026lt;/style\u0026gt; 非父子关系\ngraph TD subgraph 关系图 A[组件A] --\"父子关系\"--\u003e B[组件B] A[组件A] --\"父子关系\"--\u003e C[组件C] end subgraph grammer D[\"父子关系\"] --\u003e E[\"props\"] D[\"父子关系\"] --\u003e F[\"$emit\"] G[\"非父子关系\"] --\u003e H[\"provide \u0026 inject\"] G[\"非父子关系\"] --\u003e I[\"eventbus\"] J[\"通用解决方案： Vuex（适合复杂业务场景）\"] end 2.2 props 1. 详解什么是 Prop? 定义： 组件上注册的一些自定义属性 作用：向子组件传递数据 特点：可以传递任意数量/类型的 prop，用列表来展示 2. props 校验 避免组件中的prop乱传的现象，为组件的prop指定验证要求，不符合眼球，控制台就会报错，帮助开发者重新快速发现错误\n语法：\n类型校验\nprops:{ 校验的属性名：类型 \u0026lt;!-- Number String Boolean --\u0026gt; } 非空校验\n默认值\n自定义校验\nprops: { 校验的属性名：{type:Number}, \u0026lt;!-- Number String Boolean --\u0026gt; required: true,\u0026lt;!--true表示必填--\u0026gt; default: 默认值, \u0026lt;!--给一个默认值, 如果数据缺失可以按照默认值来--\u0026gt; \u0026lt;!--非空和默认值是互斥的--\u0026gt; validator(value){ \u0026lt;!--自定义校验逻辑,value就是在父组件中传递过来的值--\u0026gt;\t} } 3. Prop \u0026amp; data的区别及单项数据流知识点 共同点： 都可以给组件提供数据\n区别：谁的数据谁负责原则\ndata 的数据是自己的 -\u0026gt; 随便改。例如数据框中可以++ \u0026ndash;\nprop的数据是外部的 -\u0026gt; 不能直接改，要遵循单向数据流原则\n*单向数据流原则：父组件的prop有变化，会自动向下流动，影响子组件\n2.3 非父子通信（拓展）- event bus 事件总线 作用：非父子组件之间，进行简易消息传递（复杂场景-\u0026gt; Vuex）\n因为两个组件是非父子关系，所以我们要创建一个两个或多个组件都能访问到的事件总线（空Vue实例）-》utils/EventBus.js\n本质是利用vue的事件机制来进行消息传递\nimport Vue from \u0026#39;vue\u0026#39; const Bus = new Vue() export defalut Bus A组件（接收方），监听Bus实例的事件\ncreated(){ \u0026lt;!-- $on 是表示事件监听的意思--\u0026gt; Bus.$on(\u0026#39;sending\u0026#39;,(msg)=\u0026gt; { this.msg = msg }) } B组件（发送方），触发Bus实例的事件\nVus.\u0026amp;emit(\u0026#39;sendMsg\u0026#39;, \u0026#39;这是一个消息\u0026#39;) graph TD 组件A -.1.监听.-\u003e Bus 组件B --\"2.发送通知，触发Bus\"--\u003e Bus Bus--\"3.Bus被触发，组件A在监听同时也被触发\"--\u003e 组件A 组件C -.1.监听.-\u003e Bus Bus--\"3.Bus被触发，组件A在监听同时也被触发\"--\u003e 组件C 完整的代码写法： \u0026lt;!-- /utils/EventBus.js --\u0026gt; \u0026lt;!-- 总线 Bus--\u0026gt; import Vue from \u0026#39;vue\u0026#39; const Bus = new Vue() export default Bus \u0026lt;!-- Base A.vue 事件的接收方 --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;base-a\u0026#34;\u0026gt; 我是A组件（接受方） \u0026lt;p\u0026gt;{{msg}}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import Bus from \u0026#39;../utils/EventBus.js\u0026#39; export default{ data(){ return{ msg: \u0026#39;\u0026#39;, } }, created(){ Bus.$on(\u0026#39;sendMsg\u0026#39;,(msg)=\u0026gt;{ this.msg = msg }) } } \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt;\u0026lt;/style\u0026gt; \u0026lt;!-- Base B.vue 事件的发送方 --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;base-b\u0026#34;\u0026gt; \u0026lt;div\u0026gt;我是B组件（发布方）\u0026lt;/div\u0026gt; \u0026lt;button @click=\u0026#34;sendMsgFn\u0026#34;\u0026gt;发送消息\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import Bus from \u0026#39;../utils/EventBus\u0026#39; export default{ methods: { sendMsgFn(){ // 注意 这部分的方法名 要与 Base A 接收的方法名一致 Bus.$emit(\u0026#39;sendMsg\u0026#39;,\u0026#39;今天天气好好呀!!\u0026#39;) }, }. } \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt;\u0026lt;/style\u0026gt; 2.4 非父子通信（扩展） - provide \u0026amp; inject ​\tproject \u0026amp; inject 作用： 跨层级共享数据\n在顶层provide，可以在第三层inject graph TD Provide --\u003e 组件1 Provide --\u003e 组件2 Provide --\u003e 组件3 组件2 --\u003e Inject 组件2 --\u003e 组件2.1 组件2 --\u003e 组件2.2 父组件 provide 提供数据 \u0026lt;script\u0026gt; export default { provide(){ return { // 普通类型 【非响应式】 // 意味着 父组件 修改普通类型 不会影响 子孙组件的数据 color: this.color // 复杂类型 【响应式】 // 意味着父组件 修改普通类型，会影响 子孙组件的数据 userInfo : this.userInfo } }, data(){ return { color: \u0026#39;pink\u0026#39;, userInfo: { name: \u0026#39;啦啦啦\u0026#39;, age: 18 } } } } \u0026lt;/script\u0026gt; 子组件/ 孙组件 inject提供数据 \u0026lt;template\u0026gt; \u0026lt;div class = \u0026#34;grandSon\u0026#34;\u0026gt; 我是GrandSon组件 {{ color }} {{ userInfo.name }} \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { // 接收 provide中提供的数据 inject: [\u0026#39;color\u0026#39;, \u0026#39;userInfo\u0026#39;] } \u0026lt;/script\u0026gt; 2.3 v-model 原理 原理\nv-model 本质上是语法糖。利于应用在输入框上，代表value属性和input事件的合写。本笔记只针对于输入框进行解释，v-model会自动判断是复选框还是输入框。\n作用： 提供数据的双向绑定\n数据变，视图跟着变 :value 视图变， 数据跟着变 @input 注意： $event 用于在模版中，获取事件的形参\n\u0026lt;template\u0026gt; \u0026lt;div id = \u0026#34;app\u0026#34;\u0026gt; \u0026lt;!-- 使用 v-model --\u0026gt; \u0026lt;input v-model = \u0026#34;msg\u0026#34; type=\u0026#34;text\u0026#34;\u0026gt;\u0026lt;/input\u0026gt; \u0026lt;!-- 使用 原始版本 --\u0026gt; \u0026lt;!--监听input,一旦对话框内发生变化，将事件的值传给data中的msg, :value是绑定msg \u0026amp;event值得是拿到改事件的形参--\u0026gt; \u0026lt;input :value = \u0026#34;msg\u0026#34; @input= \u0026#34;msg = $event.target.value\u0026#34; type=\u0026#34;text\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 2.3.1表单类组件封装 \u0026amp; v-model 简化代码 表单类组件 封装 -\u0026gt; 实现子组件和父组件 父传子： 数据应该是父组件 props 传递过来， v-model 拆解 绑定数据 子传父： 监听输入，子传父传值给父组件修改 \u0026lt;!-- 父组件 App.vue--\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div class = \u0026#34;app\u0026#34;\u0026gt; \u0026lt;BaseSelect :cityId = \u0026#34;selectId\u0026#34; @changeId=\u0026#34;selecteId = $event\u0026#34;\u0026gt;\u0026lt;/BaseSelect\u0026gt; // 使用 $event 可以拿到 对应方法的形参值 \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import BaseSelect from \u0026#39;./components/BaseSelect.vue\u0026#39; export default { data(){ return {selectId :\u0026#39;102\u0026#39;} }, components: {BaseSelect} } \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt;\u0026lt;/style\u0026gt; \u0026lt;!--子组件--\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; // @change 监听改变事件 \u0026lt;select :value = \u0026#34;cityId\u0026#34; @change = \u0026#34;handleChange\u0026#34;\u0026gt; \u0026lt;option value=\u0026#39;101\u0026#39;\u0026gt;北京\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#39;102\u0026#39;\u0026gt;上海\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { props: { cityId: String }, methods:{ handleChange(e){ this.$emit(\u0026#39;changeId\u0026#39;,e.target.value) } } } \u0026lt;/script\u0026gt; 父组件 v-model简化代码，实现子组件和父组件数据 双向绑定\n为什么在父组件添加 v-model， 因为子组件无法修改父组件传递上来的数据 子组件： props 通过value 接收，事件触发 input 父组件： v-model 给组件直接绑定数据 :value+@input \u0026lt;!-- 父组件 App.vue--\u0026gt; \u0026lt;!-- v-model =\u0026gt; value +@input--\u0026gt; \u0026lt;!-- 因为 v-model本质是value和input所以在使用时，我们要进行配置--\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div class = \u0026#34;app\u0026#34;\u0026gt; \u0026lt;BaseSelect v-model=\u0026#34;selectId\u0026#34;\u0026gt;\u0026lt;/BaseSelect\u0026gt; // 使用 $event 可以拿到 对应方法的形参值 \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import BaseSelect from \u0026#39;./components/BaseSelect.vue\u0026#39; export default { data(){ return {selectId :\u0026#39;102\u0026#39;} }, components: {BaseSelect} } \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt;\u0026lt;/style\u0026gt; \u0026lt;!--子组件--\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; // @change 监听改变事件 \u0026lt;select :value = \u0026#34;value\u0026#34; @change = \u0026#34;handleChange\u0026#34;\u0026gt; \u0026lt;option value=\u0026#39;101\u0026#39;\u0026gt;北京\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#39;102\u0026#39;\u0026gt;上海\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { props: { value: String }, methods:{ handleChange(e){ this.$emit(\u0026#39;input\u0026#39;,e.target.value) } } } \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt;\u0026lt;/style\u0026gt; 关于表单类基础组件封装思路\n父传子： 父组件动态传递prop数据，拆解v-model，绑定数据\n子传父： 监听输入，子传父传值给父组件修改\n本质：实现子组件和父组件数据的双向绑定\nv-model 简化代码的核心步骤\n子组件：props 通过value接收，事件触发input 父组件： v-model 给组件直接绑定数据 2.3.2 关于.sync修饰符 作用： 实现 子组件 与 父组件数据的双向绑定，简化代码 特点： prop属性名，可以自定义，非固定为value 场景：封装弹框类的基础组件，visible属性true显示 false隐藏 本质： :属性名和@update:属性名合并 \u0026lt;!-- 父组件 --\u0026gt; \u0026lt;!-- 简化版本 --\u0026gt; \u0026lt;BaseDialog :visible.sync = \u0026#34;isShow\u0026#34;/\u0026gt; \u0026lt;!-- 完整版本 --\u0026gt; \u0026lt;BaseDialog :visible = \u0026#34;isShow\u0026#34; @update: visible=\u0026#34;isShow = $event\u0026#34;/\u0026gt; \u0026lt;!-- 子组件 --\u0026gt; props: { \u0026lt;!-- 接收的值 --\u0026gt; visible: Boolean }, \u0026lt;!-- 这边要写上更新的属性 --\u0026gt; this.$emit(\u0026#39;update:visible\u0026#39;, false) 2.4 ref 和 $refs 作用：利用 ref 和 $refs 可以用于 获取 dom元素或组件实例\n特点：查找范围 -\u0026gt; 当前组件内 （更精确稳定）\n步骤：\n获取dom\n目标标签 - 添加 ref 属性 \u0026lt;div ref = \u0026#34;chartRef\u0026#34;\u0026gt; 我是渲染图表的容器\u0026lt;/div\u0026gt; 恰当时间 (至少等dom元素渲染出来)，通过this.$refs.xxx,获取目标标签 mounted(){ console.log(this.$refs.chartRef) }, 获取组件\n目标组件 - 添加 ref 属性 \u0026lt;BaseForm ref = \u0026#34;baseForm\u0026#34;\u0026gt;\u0026lt;/BaseForm\u0026gt; 恰当时机，通过 this.$refs.xxx，获取目标组件，就可以调用组件对象里面的方法 this.$refs.baseForm.组件方法() 2.5 Vue异步更新 与 $nextTick Vue 是异步更新DOM, 所以$nextTick 等DOM更新后，才会触发执行此方法里面的函数体。this.$nextTick(函数体)\nthis.$nextTick(()=\u0026gt;{ this.$refs.inp.focus() }) ","permalink":"https://jingyiwu-codespace.github.io/zh/posts/tech/vue/","summary":"Vue2 + Vue3","title":"学习：Vue2 \u0026 Vue3 "},{"content":"Node.js 引入 1. 什么是Node.js? Node.js 是一个跨平台 JavaScript运行环境，使开发者可以搭建服务端的JavaScript的应用程序\n作用：使用Node.js 便携服务器端程序\n编写数据接口，提供网页资源浏览功能等等 前端工程化：为后续学习Vue和React做铺垫 2. 什么是前端工程化？ 开发项目直到上线，过程中继承的所有工具和技术\n压缩工具 -\u0026gt; 体积更小，更流畅 转换工具 -\u0026gt; less 转 css， 转高版本JS 格式化工具 打包工具 -\u0026gt; 整合前端代码 脚手架工具 自动化部署 node.js 可以主动读取前端代码的内容，对前端代码进行相应的处理\n3. Node.js 为何能执行 JS ? 首先：浏览器能执行 JS 代码，依靠的是内核中的V8引擎 （C++程序） 其次： Node.js 是基于 Chrome V8 引擎进行封装 （运行环境） 4. Node.js 安装 下载 node-v16.19.0 msi 安装程序 (指定版本：兼容vue-admin-template模版)，我不太想下载之前版本的Node.js, 发现 https://juejin.cn/post/7204454572889980965 这个教程中有切换版本的选项。\n总结 Node.js 是什么？\n基于Chrome的V8引擎，独立执行JavaScript代码环境\nNode.js 与 浏览器环境的 JS 最大区别？\nNode.js 环境中没有 BOM 和 DOM\nNode.js 有什么用？\n编写后端程序： 提供数据和网页资源等等\n前端工程化：集成各种开发使用的工具和技术\nNode.js 如何执行代码?\n在VSCode终端输入： node xxx.js 回车即可（注意路径）\nNode.js模块 1. fs 模块 - 读写文件 模块： 类似插件，封装了方法/属性\nfs模块：封装了与本机文件系统进行交互的方法/属性\n语法：\n加载 fs 模块对象\n写入文件内容\n读取文件内容\nconst fs = require(\u0026#39;fs\u0026#39;) // fs是模块标识符：模块的名字 fs.writeFile(\u0026#39;文件路径\u0026#39;, \u0026#39;写入内容\u0026#39;,err=\u0026gt;{ // 写入后的回调函数 }) fs.readFile(\u0026#39;文件路径\u0026#39;,(err,data)=\u0026gt;{ // 读取后的回调函数 if(err)console.log(err) else console.log(data) // data是文件内容的Buffer数据流 // 这时候是16进制 //如果想显示原有字符 console.log(data.toString()) }) 2. path 模块-路径处理 问题： Node.js 代码中，相对路径是根据终端所在路径来查找，可能无法找到你想要的文件\nconst fs = require(\u0026#39;fs\u0026#39;) fs.readFile(\u0026#39;../test.txt\u0026#39;,(err,data)=\u0026gt;{ if (err) console.log(err) else console.log(data.toString()) }) 解决方案：\n建议： 在Node.js 代码中使用绝对路径\n补充： _dirname 内置变量 (获取当前模块目录-绝对路径)\n注意：path.join() 会使用特定于平台的分隔符，作为定界符，将所有给定的路径片段连接在一起\nconst fn = request (\u0026#39;fs\u0026#39;) const path = require(\u0026#39;path\u0026#39;) cnosole.log(__dirname) fs.readFile(path.join(__dirname,\u0026#39;../test.txt\u0026#39;),(err,data)=\u0026gt;{ if (err)console.log(err) else console.log(data.toString()) }) 3. 案例-压缩前端 html 需求：把 回车符 (\\r) 和换行符 (\\n)去掉后，写入到新的html文件中\n步骤：\n读取源html文件内容 正则替换字符串 写入到新的html文件中 4. URL 的端口号 URL: 统一资源定位符 端口号：标记服务器里不同功能的服务程序 端口号范围： 0-65535之间的任意整数 注意：http协议，默认访问80端口\n常见的服务程序 web服务程序： 用于提供网上信息浏览功能 注意： 0-1023 和一些特定端口号被占用，自己编写服务程序请避开使用 总结\n端口号的作用？\n标记区分服务器里__不同的服务程序__，通过端口号访问不同的功能\n什么叫web服务程序？\n提供浏览器 网上信息浏览的程序代码\n5. http 模块 - 创建web服务 创建web服务并响应内容给浏览器\n步骤：\n加载 http模块， 创建Web服务对象\n监听request请求事件，设置响应头和响应体\nres 是响应对象\n配置端口号并启动Web服务\n浏览器请求： http://localhost:3000 测试\n(localhost： 固定代表本机的域名)\nconst http = require(\u0026#39;http\u0026#39;) const server = http.creatServer() server.on(\u0026#39;request\u0026#39;,(req,res)=\u0026gt;{ // 设置响应头：内容类型，普通文本；编码格式utf-8 res.setHeader(\u0026#39;Content-Type\u0026#39;,\u0026#39;text/plain;charset=utf-8\u0026#39;) // 设置响应体内容，结束本次请求与响应 res.end(\u0026#39;您好，欢迎使用node.js创建的web服务\u0026#39;) }) // 1.3 配置端口号并启动Web服务 // 启动计算机进程监听 是否有人请求 server.listen(3000,()=\u0026gt;{ console.log(\u0026#39;Web 服务已经启动\u0026#39;) }) 6. 案例 - 浏览时钟 基于Web服务，开发提供网页资源的功能\n步骤：\n基于 http 模块，创建 Web 服务 使用 req.url 获取请求资源路径，判断并读取 index.html 里面的字符串内容返回给请求方 其他路径，暂时返回不存在的提示 运行 Web 服务，用浏览器发起请求测试 // 1. 引入模块 const fs = require(\u0026#39;fs\u0026#39;) const path = require(\u0026#39;path\u0026#39;) const http = require(\u0026#39;http\u0026#39;) const server = http.createServer() // 2. 使用req.url 获取请求资源路径，并读取index.html 里面的字符串返回至请求方 server.on(\u0026#39;request\u0026#39;, (req, res) =\u0026gt; { if (req.url === \u0026#39;/index.html\u0026#39;) { fs.readFile(path.join(__dirname, \u0026#39;dist/index.html\u0026#39;), (err, data) =\u0026gt; { if (err) console.log(err) else { // 设置响应内容类型 html 超文本字符串，让浏览器解析成标签网页等 res.setHeader(\u0026#39;Content-Type\u0026#39;, \u0026#39;text/html;charset=utf-8\u0026#39;) res.end(data.toString()) } }) } else { // 3. 其他路径暂时返回不存在提示 res.setHeader(\u0026#39;Content-Type\u0026#39;, \u0026#39;text/html;charset=utf-8\u0026#39;) res.end(\u0026#39;请求路径不存在\u0026#39;) } }) server.listen(8080, () =\u0026gt; { console.log(\u0026#39;原神启动!!\u0026#39;) }) 模块化 1. 定义 CommonJS 模块是为 Node.js 打包 JavaScript 代码的原始方式。 Node.js 还支持浏览器和其他 JavaScript 运行时使用的ECMAScript模块 标准。 在Node.js中，每一个文件都被视为一个单独的模块 概念： 项目是由很多的模块文件组成\n好处： 提高代码复用性，按需加载，独立作用域\n使用：需要标准语法导出、导入进行使用。这个标准语法就是 CommomJS\n2. 使用 1. 语法 导出： module.exports = {} 导入：require(\u0026lsquo;模块名或路径\u0026rsquo;) 2. 模块名或路径 CommomJS 标准 内置模块：直接写名字 （例如：fs, path, http）\n自定义模块： 写模块文件路径（例如： ./utils.js）\nconst baseURL = \u0026#39;http://hmajax.itheima.net\u0026#39; const getArraySum = arr =\u0026gt; arr.reduce((sum,val)=\u0026gt;sum+=val,0) module.exports = { 对外属性1:baseURL, 对外属性2:getArraySum } const obj = require(\u0026#39;模块名或路径\u0026#39;) // obj 等于 module.exports 导出的对象 总结：\nNode.js 中什么是模块化?\n每个文件都是独立的模块\n模块之间如何联系？\n使用特定的语法，导出和导入使用\nCommonJS 标准规定如何导出和导入模块？\n导出： module.exports = {}\n导入： require(\u0026lsquo;模块名或路径\u0026rsquo;)\n模块名/路径如何选择？\n内置模块，直接写名字，例如：fs ,path, http 等\n自定义模块，写模块文件路径，例如：./utils.js\nECMAScript 标准 - 默认到处导入 封装并导出基地址和求数组元素和的函数\n默认标准使用：\n导出： export default() 导入：import 变量名 from \u0026lsquo;模块名或路径\u0026rsquo; 注意： Node.js 默认支持 CommonJS 标准语法。 如需使用ECMAScript标准语法，在运行模块所在文件夹新建 package.json 文件，并设置 {'type':'module'}\nconst baseURL = \u0026#39;http://hmajax.itheima.net\u0026#39; const getArraySum = arr=\u0026gt;{ arr.reduce((sum,val)=\u0026gt; sum+=val,0) } // 导出 export default { 对外属性1:baseURL, 对外属性2:getArraySum } // 导入 import obj from \u0026#39;模块名或路径\u0026#39; // obj 等于 export default 导出对象 总结：\nECMAScript 标准规定 默认到处和导入模块\n导出：export defalut{}\n导入： import 变量名 from \u0026rsquo; 模块名或路径 '\n如何让Node.js 切换模块为ECMAScript?\n运行模块所在文件夹，新建 package.json并设置\n{\u0026quot;type\u0026quot;:\u0026quot;module\u0026quot;}\nECMAScript 标准 - 命名导出和导入 封装并导出基地址和求数组元素和的函数\n命名标准使用\n导出： export修饰定义语句 导入：import (同名变量) from \u0026lsquo;模块名和路径\u0026rsquo; 如何选择命名/默认导出导入\n按需加载，使用命名导出和导入 全部加载，使用默认导出导入 export const baseURL = \u0026#39;http://hmajax.itheima.net\u0026#39; export const getArraySum = arr =\u0026gt; arr.reduce((sum,val)=\u0026gt;sum+=val,0) import {baseURL, getArraySum} from \u0026#39;模块名或路径\u0026#39; 总结：\nNode.js 支持两种模块化辨准\nCommonJS 标准语法 (默认)\nECMAScript 标准语法\nECEAScript 标准， 命名导出和导入的语法\n导出： export 修饰定义的语句\n导入： import { 同名变量 } from \u0026lsquo;模块名或路径\u0026rsquo;\nECEAScript 标准，默认导出和导入语法\n导出：export default {}\n导入：import 变量名 from \u0026lsquo;模块名或路径\u0026rsquo;\n包 包：将模块，代码，其他资料聚合成一个文件夹\n1. 包分类 项目包 ： 主要用于编写项目和业务逻辑 软件包： 封装工具和方法进行使用 要求： 根目录中，必须有package.json文件 （记录包的清单信息）\n注意： 导入软件包时，引入的默认是 index.js 模块文件/ main 属性指定的模块文件 （utils 工具包的唯一出口，作用：把所有工具模块方法集中起来，统一向外暴露）\n放入视频，因为老师有一些文件结构，我没有截图\n总结：\n什么是包？\n将模块，代码，其他资料聚合成的文件夹。文件我们称之为模块\n包分为2类\n项目包： 编写项目代码的文件夹\n软件包： 封装工具和方法\npackage.json 文件的作用？\n记录了包的信息/作者/名字/入口信息\n导入一个包文件夹的时候，默认导入index.js 文件或package main属性指定的文件\nnpm npm 是Node.js 标准的软件包管理器，作为下载和管理 Node.js 包依赖的方式\n##1 .npm 软件包 使用\n初始化清单文件： npm init -y （得到package.json 文件，可以记录当前项目中，下载了多少软件包） 下载软件包： npm i 软件包名称 使用软件包 2. 使用案例 图解 总结：\nnpm软件包管理器作用？\n下载软件包以及管理版本\n初始化项目清单文件 package.json 命令\nnpm init -y\n下载软件包的命令？\nnpm i 软件包名字\n下载的包 存放地址\n当前项目下的node_modules中，并记录package.json中\n2. npm - 安装所有依赖 若收到项目文件中不包含node_modules 是否能正常运行？\n不能，缺少依赖的本地软件包\n原因： 因为自己用 npm下载依赖比磁盘传递拷贝要快得多\n__解决方案: __\n项目终端输入命令： npm i\n下载package.json 中记录的所有软件包\n3. npm - 全局软件包 nodemon 软件包区别 本地软件包：当前项目内使用，封装属性和方法，存在于node_modules 全局软件包：本机所有项目使用，封装命令和工具，存在于系统设置的位置 nodemon作用：代替node命令，检测代码更改，自动重启程序\nnodemon使用 安装 npm i nodemon -g (-g 代表安装到全局环境中) 运行 nodemon 待执行的目标 js 文件 总结：\n本地软件包和全局软件包区别\n本地软件包，作用与当前项目，封装属性与方法\n全局软件包，本机所有项目使用，封装命令和工具\nnodemon 全局软件包的作用\n替代node命令，检测代码更改，自动重启程序\nnodemon怎么用？\n先确保安装 npm i nodemon -g （只有是命令和工具的软件包才安装到全局）\n使用 nodemon 执行目标js文件\nNode.js 总结 Node.js 模块化 概念： 每个文件当做一个模块，独立作用域，按需加载\n使用： 采用特点的标准语法导出和导入进行使用\nCommonJS 标准\n导出：module.exports = {}\n导入：require('模块名或路径')\nECMAScript标准\n默认模式：\n导出：export default {}\n导入：import 变量名 from '模块化路径'\n命名模式:\n导出：export 修饰定义语句\n导入：import {同名变量} from'模块化路径' CommonJS 标准：一般应用在Node.js 项目环境中\nECMAScript标准：一般应用在前端工程化项目中\nNode.js 包 把模块文件，代码文件，其他资料聚合成一个文件夹\n项目包：编写项目需求和业务逻辑文件夹\n软件包：封装工具和方法进行使用的文件夹 (一般使用npm管理)\n本地软件包： dayjs, loads, …\n作用当前项目，一般封装的属性/方法，供项目调用编写业务需求\n全局软件包: nodemon\n作用在所有项目，一般封装的命令/工具，支撑项目运行\nNode.js 常用命令 功能 命令 执行js文件 node index.js 初始化 packpage.json npm init -y 下载本地软件包 npm i 软件包名 下载全局软件包 npm i 软件包名 -g 删除软件包 npm uni 软件包名 Webpack 引入 1. 定义 本质上， webpack是一个用于现代 JavaScript 应用程序的 静态模块打包工具，当webpack处理应用程序时，它会在内部从一个或多个入口点构建一个依赖图 (dependency graph), 然后将你的项目中所需要的每一个模块组合成一个或多个 bundles，它们均为静态资源，用于展示你的内容\n静态模块： 指的是编写代码过程中的 html, css,js,图片等固定内容的文件\n打包：把静态模块内容 压缩，整合，转译等等 （前端工程化）\n把 less/sass 转换成 css代码 把 ES6+ 降级到 ES5 支持多种模块标准语法 关于vite (另一种打包工具)，很多项目还是基于webpack构建，也为Vue, React脚手架使用做铺垫\n2. 执行步骤 准备项目和源代码\n准备 webpack 打包的环境\n新建自定义配置\n// 导入/导出标准 \u0026#34;type\u0026#34;: \u0026#34;module\u0026#34;, // 添加自定义命令，调用build，使用webpack \u0026#34;scripts\u0026#34;: { \u0026#34;test\u0026#34;: \u0026#34;echo \\\u0026#34;Error: no test specified\\\u0026#34; \u0026amp;\u0026amp; exit 1\u0026#34;, \u0026#34;build\u0026#34;: \u0026#34;webpack\u0026#34; } 运行自定义命令打包观察效果\nnpm run 自定义命令\n出现 dist 文件夹\nWebpack 打包入口和出口修改 1. 默认值 默认打包入口： src/index.js 默认打包出口：dist/main.js 步骤：\n项目根目录，新建 webpack.config.js 配置文件 导出配置对象，配置入口，出口文件的路径 重新打包观察 注意: 只有和入口产生直接/简介的引入关系，才会被打包\nconst path = require(\u0026#39;path\u0026#39;) module.exports = { entry: path.resolve(__dirname, \u0026#39;src/login/index.js\u0026#39;), output:{ path: path.resolve(__dirname, \u0026#39;dist\u0026#39;), filename: \u0026#39;./login/index.js\u0026#39;, clean: true // 生成打包内容后，清空输出目录，只在webpack 5以上的版本才能使用 } } 2. Webpack的官方网址 目前b站教的是webpack5 webpack.docschina.org/concepts\n3. Webpack 修改入口 (entry) 在 webpack configuration中配置entry属性，来指定一个或多个不同的入口起点\n文件夹-\u0026gt; 项目根目录中的webpack.config.js\nmodule.exports = { entry: \u0026#39;./path/file.js\u0026#39; }; 4. Webpack 修改出口 (output) 在 webpack configuration.js中配置output属性，表明webpack在哪里输出创建的bundle\n文件夹-\u0026gt; 项目根目录中的webpack.config.js\nconst path = require(\u0026#39;path\u0026#39;); module.exports = { entry: \u0026#39;./path/file.js\u0026#39;, output: { // 输出路径 path: path.resolve(__dirname,\u0026#39;dist\u0026#39;) // 打包后文件的名字 filename:\u0026#39;my-first-webpack.bundle.js\u0026#39; } } 5. 案例 用户登录 前端工程化思路： Webpack打包后的代码，在前端页面中的使用\n步骤：\n准备用户登录页面 编写核心JS逻辑代码 打包手动复制网页到dist下，引入打包后的js，运行 6. Webpack 自动生成html文件 前情提要： 之前打包后我们将原始的html文件，手动添加至输出文件夹，这回我们让webpack自动找到对应的html文件\n1. Html-wabpack-plugin 插件 HtmlWebpackPlugin简化了HTML文件的创建，以便为webpack包提供服务，这对于文件名中包含哈希值，并且哈希值会随着每次编译而改变的webpack包非常有用。可以让该插件为用户生成HTML 文件，使用lodash提供模版，或者使用自己的loader\n安装 npm install --save-dev html-webpack-plugin\n\u0026ndash;sav-dev 表示只在开发环境中使用\n基本用法及步骤 无论是什么功能都是 找包-\u0026gt; 下包-\u0026gt; 配置包\n下载 Html-wabpack-plugin 本地软件包\n该插件将为你生成一个HTML5文件，在body中使用script变迁引入你所有webpack生成的bundle，只需添加该插件到你的webpack配置中\nconst HtmlWebpackPlugin = require(\u0026#39;html-webpack-plugin\u0026#39;); const path = require(\u0026#39;path\u0026#39;); module.exports = { entry: index.js, output:{ path: path.resolve(__dirname, \u0026#39;./dist\u0026#39;), // 输出文件 filename: \u0026#39;index_bundle.js\u0026#39;, }, //这个位置 plugins: [new HtmlWepackPlugin()], }; 配置webpack.config.js 让 Webpack 拥有插件功能\n会在dist文件下生成index.html， 如果有多个webpack入口，都会在已生成HTML文件中的\u0026lt;script\u0026gt;标签内引入。\n如果在webpack的输出中有任何css资源 (例如，使用MiniCssExtractPlugin提取的CSS)，那么这些资源也会在HTML文件\u0026lt;head\u0026gt;元素中的\u0026lt;link\u0026gt;标签内引入\n更多配置可以自行添加 webpack.config.js\n{ \u0026#34;entry\u0026#34;: \u0026#34;index.js\u0026#34;, \u0026#34;output\u0026#34;: { \u0026#34;path\u0026#34;: __dirname + \u0026#34;/dist\u0026#34;, \u0026#34;filename\u0026#34;: \u0026#34;index_bundle,js\u0026#34; }, // new 一个对应的插件对象 \u0026#34;plugins\u0026#34;: [ new HtmlWebpackPlugin({ // html 标题 \u0026#34;title\u0026#34;: \u0026#34;My App\u0026#34;, \u0026#34;filename\u0026#34;: \u0026#34;assets/admin.html\u0026#34; }) ] } 7. Webpack打包css代码 Webpack 默认只识别 js代码， 加载器可以让webpack识别更多类型的模块文件\n加载器的官方文档： webpack.docschina.org/loaders/\n加载器 css-loader: 解析css代码\n加载器style-loader : 将解析后的css代码插入到DOM\n1. 安装 css-loader npm install --save-dev css-loader\n2. file.js import css from \u0026quot;file.css\u0026quot;;\ncss 文件与入口文件产生引入关系，webpack打包时会先找到入口，分析在入口中引入了其他的一些文件，然后将文件内容一起打包\n3. 将loader引用到webpak的配置中 webpack.config.js\nmodule.exports = { module: { rules: [ { test: /\\.css$i, // 不区分大小写的，以css结尾的文件 user:[\u0026#34;style-loader\u0026#34;,\u0026#34;css-loader\u0026#34;], // 使用加载器的顺序是从后向前使用 } ] } }; 步骤 准备 css 文件代码引入到 src/login/index.js（压缩转译处理等） 下载 css-loader 和 style-loader 本地软件包 配置webpack.config.js 让Webpack拥有该加载器功能 8. 优化 - 提取 css 代码 上节课学会了如何打包 css 代码，但是是融合在 .js 文件中的。这次将css 代码单独提取出来\n好处： css文件可以被浏览器缓存，减少 .JS 文件体积， 可以让浏览器加载更快，浏览器可以并行下载 css/js 这两个文件的代码，使网页尽快展给用户。\n1. 使用 MiniCssExtractPlugin插件步骤 下载插件\nnpm install --save.dev mini-css-extract-plugin\n建议 mini-css-extract-plugin 与 css-loader一起使用，但是不能与 style-loader一起使用!!\n配置插件\nconst MiniCssExtractPlugin = require(\u0026#39;mini-css-extract-plugin\u0026#39;) module.exports = { plugins: [new MiniCssExtractPlugin()] module: { rules: [ { test: /\\.css$i, // 不区分大小写的，以css结尾的文件 user:[MiniCssExtractPlugin,\u0026#34;css-loader\u0026#34;], // 使用加载器的顺序是从后向前使用 } ] } }; 9. 优化 - 提取 css 代码的压缩 css 代码提取后并没有压缩， 再次使用插件解决。\n找包下包配置包\ncss-minimizer-webpack-plugin 插件 找包\n下包\nnpm install css-minimizer-webpack-plugin\n配置包\nconst MiniCssExtractPlugin = require(\u0026#39;mini-css-extract-plugin\u0026#39;) const CssMinimizerPlugin = require(\u0026#39;css-minimizeer-webpacke-plugin\u0026#39;) module.exports = { // ... // 优化 optimization:{ minimizer:[ // 在webpack@5中可以使用 ... 语法来扩展现有的minimizer (即 terser-webpack-plugin)，将下一行取消注释 (保证JS代码还能被压缩处理) ..., new CssMinimizerPlugin(), ] } }; 10. Webpack 打包 less 1. less-loader 将Less编译为CSS的loader\n找包\n下包\nnpm install less less-loader --save-dev\n配置包\nmodule.exports = { module: { rules: [ { test: /\\.less$i, // 不区分大小写的，以css结尾的文件 use: [ \u0026#39;style-loader\u0026#39;, \u0026#39;css-loader\u0026#39;, \u0026#39;less-loader\u0026#39;, ] // 从后向前使用 } ] } }; 步骤 新建 less 代码 （设置背景图）并引入到 src/login/index.js 下载 less 和 less-loader 本地软件包，因为less-loader需要配合less软件包使用 配置 webpack.config.js 11. Webpack资源模块 资源模块 （asset module）是一种模块类型，允许使用资源文件 (字体，图标等）而无需配置额外 loader\n资源模块类型 (asset module type), 通过添加4种新的模块类型，替换所有loader\nasset/resource 发送一个单独文件并导出URL，之前通过使用file-loader实现。针对图片/文件i asset/inline 导出一个资源的data URI, 之前通过使用url-loader实现 asset/source 导出资源的源代码。之前通过使用raw-loader实现。针对txt文本，使用场景不多 asset 在导出一个data URI 和发送一个单独文件之间自动选择。之前通过使用url-loader，并且配置资源体积限制实现。文件大于8kb使用asset/resource，小于8kb使用assest/inline 当在webpack5中使用旧日的assets loader (如 file-loader/url-loader/raw-loader 等)和asset模块时，你可能想停止当前 asset模块的处理，并再次启动处理，这可能会导致 asset重复，你可以通过将 asset模块的类型设置为 javascript/auto来解决\n1. 打包图片 资源模块： Webpack5 内置资源模块 (字体/图片等) 打包，无需额外loader\n步骤：\n配置 webpack.config.js 让Webpack拥有打包图片功能\n占位符 [ hash ] 对模块内容做算法计算，得到映射的数字字母组合的字符串 占位符 [ext] 使用当前模块原本的占位符，例如：.png/.jpg等字符串 占位符 [query] 保留引入文件时代码中查询参数 (只有URL下生效) 注意：判断临界值默认为 8kb\n大于8kb文件：发送一个单独的文件并导出URL地址\n小于8kb文件：导出一个data URI （base64字符串）\nmodule.exports = { // ... module:{ rules:[ // ... { test: /\\.(png|jpg|jpeg|gif)$/i, type:\u0026#39;asset\u0026#39;, generator:{ // 默认以output path作为路径 filename: \u0026#39;assets/[hash][ext][query]\u0026#39; } } ] } } 12. webpack热更新环境搭建 之前改代码，需要重新打包才能运行查看，效率很低\n1. 开发环境 配置webpack-dev-server 快速开发应用程序\n开发环境： 开发 mode: 'development' 生产环境：用户看到的页面 mode: 'production' 作用：启动Web服务，自动检测代码变化，热更新到网页\n注意：dist 目录和打包内容存在内存里 （更新快）\n2. 下包 Webpackp-dev-server npm install --save-dev webpack-dev-server\n3. 配置包 设置模式为开发模式 自定义命令 使用 npm run dev来启动开发服务器，试试热更新效果 // package.json 设置自定义命令 scripts: { \u0026#34;build\u0026#34;: \u0026#34;webpack\u0026#34;, \u0026#34;dev\u0026#34;:\u0026#34;webpack server --open\u0026#34; //自动弹出浏览器 } module.exports = { mode: \u0026#39;development\u0026#39;, entry:{ index: \u0026#39;./src/index.js\u0026#39;, print:\u0026#39;./src/print.js\u0026#39; }, devtool: \u0026#39;inline-source-map\u0026#39;, devServer:{ static:\u0026#39;/dist\u0026#39; } } 以上配置表示\nwebpack-dev-server 借助 http模块创建8080默认web服务，将dist目录下的文件serve到localhost:8080下。（serve 将资源作为server可访问的文件 ），如果不设置static属性，默认使用public文件夹的内容渲染页面 webpack-dev-server根据配置，打包相关代码在内存当中，意味着不会生成新的文件，开发者肉眼不可见。以output.path的值作为服务器根目录，可以直接自己拼接访问dist目录下内容 13. Webpack 打包模式 1. 打包模式 告知Webpack使用相应模式的内置优化\n2. 分类 开发模式，生产模式\n模式名称 模式名字 特点 场景 开发模式 development 调试代码，实时加载，模块热替换 本地开发 生产模式 production 压缩代码，资源优化，更轻量 打包上线 3. 设置方式 方式1: 在webpack.config.js 配置文件设置mode选项 module.exports = { // ... mode: \u0026#39;production\u0026#39; } 方式2：在package.json命令行设置mode参数 【优先级高于配置文件，会覆盖优先级】 \u0026#34;scripts\u0026#34;:{ \u0026#34;build\u0026#34;:\u0026#34;webpack --mode=production\u0026#34;, \u0026#34;dev\u0026#34;:\u0026#34;webpack serve --mode=development\u0026#34; }, 4. 打包模式的应用 需求：\n在开发模式下用 style-loader内嵌更快 在生产模式下提取css代码，为了在用户的电脑上并行加载 css 和 js 的代码 方案1: webpack.config.js配置导出函数，但是局限性很大（因为只接收生产模式和开发模式）\n方案2: 借助 cross-env（跨平台通用）包命令，设置参数区分环境\n下载 cross-env 软件包到当前项目 配置自定义命令，传入参数名和值 (会绑定到process.nev对象下) 在webpack.conifg.js 区分不同环境使用不同配置 重新打包观察两种配置区别 \u0026#34;script\u0026#34;:{ \u0026#34;test\u0026#34;:\u0026#34;echo \\\u0026#34;Error: no test specified\\\u0026#34;\u0026amp;\u0026amp; exit 1\u0026#34;, \u0026#34;build\u0026#34;:\u0026#34;cross-env NODE_ENV=production webpack --mode=production\u0026#34;, \u0026#34;dev\u0026#34;:\u0026#34;cross-env NODE_ENV=development webpack serve --open --mode=development\u0026#34; } 方案3: 配置不同的webpack.config.js （适用于多种模式差异性较大情况）\n14. 前端-注入环境变量 前端项目中，开发模式下打印语句生效，生产模式下打印语句失效\ncross-env设置只能在Node.js环境生效，打包后代码作用在浏览器，前端代码无法访问 process.env.NODE_ENV\n解决方法依然是 找包掉包配置包 DefinePlugin插件 （内置插件无需下载）\nconst webpack = require(\u0026#39;webpack\u0026#39;) module.exports = { // ... plugins: [ // ... // 在编译时，将前端代码中匹配的变量名，替换为值或表达式 new webpack.DefinePlugin({ // key 是诸如到打包后的前端 JS 代码中作为全局变量 // value 是变量对应的值(在cross-env诸如在node.js中的环境变量字符串) \u0026#39;process.env.NODE_ENV\u0026#39;:JSON.stringfy(process.env.NODE_ENV) }) ] } 15. 开发环境调错 -source map 代码被压缩和混淆，无法正且定位源代码位置（行数和列数）\nsource map: 可以准切追踪error和warning 在原始代码的位置\n设置: web pack.config.js 配置devtool选项\nmodule.exports = { devtool:\u0026#39;inline-source-map\u0026#39; }; inline-source-map：把源码的位置信息一起打包js文件内\n注意： source map仅仅是用于开发环境，不要在生产环境使用 (防止被轻易查看源码位置)\n16. 解析别名 alias 配置模块如何解析，创建import引入路径的别名，来确保模块引入变得更简单，例如原来路径长且相对路径不安全\n// @ 代表绝对路径 import {checkPhone, checkCode} from \u0026#39;@/utils/check.js\u0026#39; const config = { resolve:{ alias:{ \u0026#39;@\u0026#39;:path.resolve(__dirname,\u0026#39;src\u0026#39;) } } } ","permalink":"https://jingyiwu-codespace.github.io/zh/posts/tech/node.jswebpack/","summary":"Basic understanding of front-end engineering","title":"学习：Node.js \u0026 Webpack "},{"content":"Day 1 1. AJAX 导入 什么是AJAX ? 异步的 JavaScript 和 XML (Asynchronous JavaScript And XML)\n使用XMLHttpRequest 对象与服务器通信，可以使用JSON/ XML/ HTML/ text 文本等格式发送和接受数据。\nAJAX 有异步特性，在不重新刷新页面的情况下与服务器通信，交换数据，或更新页面\n使用 AJAX 使用 axios 库，与服务器进行数据通信\n将XMLHttpRequest封装，代码简单\nVue React 项目中都会使用 axios\naxios({ url: \u0026#39;http://hmajax.itheima.net/api/province\u0026#39; //\u0026#39;请求的服务器连接\u0026#39; }).then(result)=\u0026gt;{ // 对服务器返回的数据做后续处理 } 学习XMLHttpRequest对象，了解AJAX底层原理\n2. URL http协议： 超文本传输协议，规定浏览器和服务器之间传输数据的格式\n网址： http://hmajax.itheima.net/api/province\n网址：协议://域名/资源路径\n名称 网址 作用 协议 http 规定传输数据的格式 域名 hmajax.itheima.net 标记服务器在互联网中的方位 资源路径 /api/province 标记资源在服务器下的具体位置 URL 查询参数\n浏览器提供给服务器的额外信息，让服务器返回浏览器想要的数据\n​\thttp://xxxx.com/xxx/xxx?param1 = value \u0026amp;\u0026amp; param2 = value2\n​\tAxios 查询参数\naxios 提供 params 选项 axios({ url:\u0026#39; http://hmajax.itheima.net\u0026#39; params: { pname:\u0026#39;河北省\u0026#39; } }).then(result=\u0026gt;{ // 处理后续code }) 常用的请求方法 对服务器资源，执行的操作\n请求方法 操作 GET 获取数据 POST 提交数据 PUT 修改数据 (全部) DELETE 删除数据 PATCH 修改数据 (部分) axios 请求配置\nurl：请求URL网址\nmethod：请求方法，GET可以省略（不区分大小写）\ndata：提交的数据\nheader: 请求头数据，通常用于传递token，可以在axios中的请求拦截器中设置公共的 headers 选项\naxios({ url : \u0026#39;目标资源地址\u0026#39;, method : \u0026#39;请求方法\u0026#39;, data :{ params ：value } }).then((result)=\u0026gt;{ }) axios({ url:\u0026#39;\u0026#39;, headers: { Authorization: `Bearer ${token}` // Bearer是授权类型 } }) axios 请求拦截器：本质是配置函数，在发起请求之前触发，对请求参数进行额外配置。一般放在基地址.baseURL的.js内 axios.interceptor.request.use(function (config) { const token = location.getItem(\u0026#39;token\u0026#39;) token \u0026amp;\u0026amp; config.headers.Authorization = `Bearer ${token}` // 在发送请求之前做些什么 return config }, function (error) { // 对请求错误做些什么 return Promise.reject(error) }) Axios 响应拦截器\n响应(response)回到 then/catch之前，触发的拦截函数，对响应结果统一处理，例如身份验证失败，统一判断并作处理；如果成功设置返回数据对象里的某个属性，在其他操作中更加简洁。一般放在基地址.baseURL的.js内\n// 添加响应拦截器 axios.interceptors.response.use(function (response) { // 2xx 范围内的状态码都会触发该函数 // 对响应数据 返回对象中的 data属性 const result = response.data // 不用写 response.data.data这么繁琐 return result; }, function (error) { if (error?.response?.status === 401) { // 这是一个条件语句，首先检查 error 对象是否存在，如果存在则继续检查其 response 属性是否存在， // 最后再检查 response 对象中的 status 属性是否等于 401。这里使用了可选链操作符 ?. // 以避免当某些属性为 null 或 undefined 时引发错误。 alert(\u0026#39;登录状态过期，请重新登录\u0026#39;) localStorage.clear() location.href = \u0026#39;login/index.html\u0026#39; } return Promise.reject(error); }); 总结：\n请求方法表明对服务器资源的操作，POST 提交数据 GET查询数据\naxios 核心配置\nurl ：请求URL网址\nmethod : 请求方法， get可以省略\nparams ： 查询参数\ndata ： 提交数据, 请求体\naxios 是一个调用函数，对请求参数进行设置\n在公共配置和设置是，统一设置在请求拦截器中\n在 axios的使用中，发现data后面时对象的格式，会自动转换成json格式\n浏览器发送至服务器 叫做 请求体， 在network -\u0026gt; playload中可以查看\n服务器返回给浏览器 叫做 响应体， 在 network -\u0026gt; 响应中可以查看\n3. axios错误处理 Axios 会在控制台返回错误信息， 为了增加用户体验，开发人员可以讲错误信息以探矿的形式展现给用户\n语法： 在 then 方法的后面，通过点语法调用 catch 方法，传入回调函数并定义形参\naxios({ // 请求选项 }).then(result=\u0026gt;{ }).catch(error=\u0026gt;{ }) axios({ url: \u0026#39;http://hmajax.itheima.net/api/register\u0026#39;, method: \u0026#39;post\u0026#39;, data: { \u0026#39;username\u0026#39;: \u0026#39;itheima789\u0026#39;, \u0026#39;password\u0026#39;: \u0026#39;123456\u0026#39; } }).then(result =\u0026gt; { console.log(result) }).catch(error =\u0026gt; { console.log(error) console.log(error.response.data.message) // 错误信息存放的位置 alert（error.response.data.message） }) 4. HTTP协议 - 请求报文 HTTP 协议： 规定了浏览器发送服务器返回内容的格式 请求报文：浏览器按照HTTP 协议要求的格式，发送给服务器的内容。所以请求报文就是遵守格式的内容集合 请求报文的组成部分 请求行： 请求方法， URL， 协议\n请求头： 以键值对的格式携带的附加信息 Content-Type: application/json\n空行： 分隔请求头，空行之后是发送给服务器的资源\n请求体： 浏览器发送的资源\n5. HTTP协议 - 响应报文 HTTP 协议： 规定了浏览器发送及服务器返回内容的格式 响应报文： 服务器按照HTTP协议要求的格式，返回给浏览器的内容 响应报文的组成部分\n响应行（状态行）：协议、HTTP响应状态码、状态信息\n状态码 说明 1xx 信息 2xx 成功 3xx 重定向消息 4xx 客户端错误 5xx 服务端错误 响应头：以键值对的格式携带的附加信息 Content-Type:Application/JSON\n空行： 分隔响应头，空行之后的是服务器返回的资源\n响应体：返回的资源\n6. 接口文档 描述接口的文章\n接口是什么？\n使用AJAX和服务器通讯时，使用的URL, 请求方法，以及参数\n7. form-serialize 插件 快速收集表单元素的值\nconst form = document.querySelector(\u0026#39;.example-form\u0026#39;) const data = serialize(form, {hash: true, empty:true}) 使用解读：\n参数1：要获取哪个表单的数据\n表单元素设置name属性，值会作为对象的属性名。建议name属性的值，最好与接口文档参数名一致\n参数2: 配置对象\nhash 设置获取数据结构\ntrue： JS 对象（推荐）一般请求体提交至服务器的格式。 false：查询字符串 empty 设置是否获取空值\ntrue：获取空值（推荐）数据结构和标签结构一致 false：不获取空值 8. API要求请求体FormData() 文件选择元素 -\u0026gt; 使用change改变事件，使用files获取监听事件的文件列表 使用FormData()传输文件 document.querySelector(\u0026#39;.upload\u0026#39;).addEventListener(\u0026#39;change\u0026#39;,e=\u0026gt;{ //1. 获取图片文件,使用files获取监听事件的文件列表 console.log(e.target.files[0]) const fd = new FormData() fd.append(\u0026#39;img\u0026#39;,e.target.files[0]) axios({ // api url:\u0026#39;\u0026#39;, method:\u0026#39;post\u0026#39;, data:fd }).then(result=\u0026gt;{ console.log(result) const imgUrl = result.data.data.url document.querySelector(\u0026#39;.img\u0026#39;).src = imgUrl }) } Day3 1. AJAX 原理 - XMLHttpRequest XMLHttpRequest （XHR）对象用于与服务器交互。通过XMLHttpRequest 可以在不刷新页面的情况下请求特定的URL，获取数据。\n这允许网页在不影响用户操作的情况下，更新页面的局部内容。\nXMLHttpRequest 在AJAX编程中被大量使用\n关系：axios 内部采用 XMLHttpRequest与服务器交互\n1. 使用 XMLHttpRequest 步骤\u0026amp;语法\nconst xhr = new XMLHttpRequest() xhr.open(\u0026#39;请求方法\u0026#39;,\u0026#39;请求url网址\u0026#39;) xhr.addEventListener(\u0026#39;loadend\u0026#39;,()=\u0026gt;{ // 响应结果 console.log(xhr.response) // 接受服务端的响应 }) xhr.send() // 给服务端发送请求 // 再来一个案例 const xhr = new XMLHttpRequest() xhr.open(\u0026#39;get\u0026#39;, \u0026#39;http://hmajax.itheima.net/api/province\u0026#39;) xhr.addEventListener(\u0026#39;loadend\u0026#39;, () =\u0026gt; { // 无论成功或失败，都会返回数据 // 返回json字符串， axios帮忙转成了js对象 console.log(xhr.response) // 转换成js对象 const data = JSON.parse(xhr.response) // 转换成字符串 console.log(data.list.join(\u0026#39;\u0026lt;br\u0026gt;\u0026#39;)) }) // 发起请求 xhr.send() 总结：\nAJAX原理\nXMLHttpRequest 对象\n为什么学习 XHR？\n了解axios内部原理\n了解服务器数据通信的方式\nXHR使用步骤？\n创建XHR对象\n调用open方法，设置url和请求方法\n监听loadend事件，接收结果\n调用send方法，发起请求\n2. XMLHttpRequest -查询参数 定义： 浏览器提供给服务器的额外信息，让服务器返回浏览器想要的数据\n语法：http://xxxx.com/xxx/xxx?参数名1=值1 \u0026amp; 参数名2=值2\n3. URLSearchParams() 用来生成查询参数\nconst paramsObj = new URLSearchParams({ 参数名1:值1, 参数名2:值2 }) const queryString = paramsObj.toString() 4. XMLHttpRequest() 数据提交 请求头设置 Content-Type：application/json\n请求体携带JSON 字符串\n在开发者控制台的 网络-\u0026gt; Fetch/XHR-\u0026gt;选择调用的接口\nconst xhr = new XML HttpRequest() xhr.open(\u0026#39;请求方法\u0026#39;，\u0026#39;请求url网址\u0026#39;) xhr.addEventListener(\u0026#39;loadend\u0026#39;,()=\u0026gt;( console.log(xhr.response) )) // 提交时，设置请求头 xhr.setRequestHeader(\u0026#39;content-type\u0026#39;,\u0026#39;application/json\u0026#39;) const user = {username:\u0026#39;itheima007\u0026#39;,password:\u0026#39;7654321\u0026#39;} // 转换成json const userJson = JSON.stringify(user) xhr.send(userJson) 2. Promise对象 定义： Promise 对象用于表示一个异步操作的最终完成（或失败）及其结果值\n目前学过的异步：AJAX, setTimeout(), setTimeInterval()\n1. 了解 优势：\n逻辑更清晰 了解axios 函数内部运作机制 能解决回调函数地狱问题 // 创建Promise对象 const p = new Promise((resolve, reject)=\u0026gt;{ // 执行一步任务并传递结果 // 成功调用： resolve(值)触发 then()执行 // 失败调用： reject(值)触发 catch()执行 }) p.then(result=\u0026gt;{ // 成功 }).catch(error=\u0026gt;{ // 失败 }) 总结：\n什么是Promise? 管理一个异步操作最终状态和结果的值的对象\n为什么学习Promise？\n成功和失败状态，可以关联对应处理程序\n了解axios内部原理\nPromise使用步骤\n创建对象 定义两个形参并执行回调函数，执行异步代码 成功和失败执行不同的函数 在.then() .catch()方法中捕捉成功或失败的结果 2. Promise 三种状态 作用： 了解Promise对象如何关联和处理函数，以及代码执行顺序\n概念： 一个Promise对象，必然处于以下几种状态之一\n待定 (pending)： 初始状态，即没有被兑现，也没有被拒绝 已兑现 (fulfilled)： 操作成功完成 已拒绝 (rejected)：操作失败 注意： Promise 对象一旦被兑现/拒绝，此状态无法被改变\n// 1. 创建Promise对象 （pending - 待定状态） const p = new Promise((resolve, reject) =\u0026gt; { console.log(\u0026#39;Promise对象内开始执行\u0026#39;) // Promise对象被创建时，代码立刻执行 // 2. 执行异步代码 setTimeout(() =\u0026gt; { // 当resolve()=\u0026gt;被调用时，Promise的状态会更改为‘fulfilled 已兑现’ // 导致then()中的回调函数执行 resolve(\u0026#39;模拟ajax请求成功\u0026#39;) // 当reject()=\u0026gt;被调用时，Promise的状态会更改为‘rejected 已拒绝’ // 导致catch()中的回调函数执行 // reject(new Error(\u0026#39;失败！\u0026#39;)) }, 2000) }) p.then(result =\u0026gt; { console.log(result); }).catch(error =\u0026gt; { console.log(error) }) 总结：\nPromise 对象有哪三种状态？\n待定 pending\n已兑现 fulfilled\n已拒绝 rejected\nPromise 状态有什么用？\n状态改变后，调用关联的处理函数\n案例： Promise 和 XMLHttpRequest 的结合\nconst p = new Promise((resolve, reject) =\u0026gt; { const xhr = new XMLHttpRequest() xhr.open(\u0026#39;GET\u0026#39;, \u0026#39;http://hmajax.itheima.net/api/provincedhdhdh\u0026#39;) xhr.addEventListener(\u0026#39;loadend\u0026#39;, () =\u0026gt; { // xhr使用响应码判断 响应成功还是失败 2xx开头都是成功 4xx都是错 // 响应码 console.log(xhr.status) console.log(xhr.response) if (xhr.status \u0026gt;= 200 \u0026amp;\u0026amp; xhr.status \u0026lt; 300) { resolve(JSON.parse(xhr.response)) } else { reject(new Error(xhr.response)) } }) xhr.send() }) p.then(result =\u0026gt; { document.querySelector(\u0026#39;.my-p\u0026#39;).innerHTML = result.list.join(\u0026#39;\u0026lt;br\u0026gt;\u0026#39;) }).catch(error =\u0026gt; { // 错误对象要用console.dir详细打印 console.dir(error) console.log(error) document.querySelector(\u0026#39;.my-p\u0026#39;).innerHTML = error.message }) Day4 1. 同步代码\u0026amp;异步代码 同步代码\n实际上浏览器按照我们书写代码的顺序一行一行地执行程序。浏览器会等待代码的解析和工作，在上一行完成后才会执行下一行。这样就很有必要，因为每一行新的代码都是建立在前面的代码的基础之上的。\n这也使得它成为一个同步程序\n异步代码\n异步编程技术使你的程序可以执行一个可能长期运行的任务同时继续对其他事件做出反应而不必等待任务完成。与此同时，你的程序也将在任务完成后显示结果\n总结：\n同步代码：逐行执行，需要在原地等待结果，才能继续向下执行 异步代码：调用后耗时，不阻塞代码继续执行（不必原地等待），在将来完成后触发一个回调函数。异步代码接收结果，使用回调函数 // 数字打印顺序 const result = 0+1 console.log(result) //1 setTimeout(()=\u0026gt;{ console.log(2) },2000) //2 // 事件相关的代码都是异步，因为不会阻塞代码执行 document.querySelector(\u0026#39;.btn\u0026#39;).addEventListener(\u0026#39;click\u0026#39;,()=\u0026gt;{ console.log(3) }) document.body.style.backgroundColor = \u0026#39;pink\u0026#39; console.log(4) // 打印顺序应该是 1 4 2 总结：\n什么是同步代码？ 逐行执行，原地等待结果，才继续向下执行其他的代码\n什么是异步代码？调用后耗时，不阻塞代码执行，将来完成后触发回调函数\nJS 中有哪些异步代码 ?\nsetTimeout/setInterval\n事件\nAJAX\n异步代码如何接收结果？依靠回调函数来接收\n2. 回调函数地狱 在回调函数中 嵌套回调函数，一直嵌套下去就形成了回调函数地狱\n缺点： 可读性差，异常无法捕获，耦合性严重，牵一发动全身\n3. Promise - 链式调用 概念： 依靠 then()方法会返回一个新生成的 Promise对象特性，继续串联下一环任务，直到结束\n细节：then()回调函数中的返回值，会影响新生成Promise对象最终状态和结果\n好处： 通过链式调用，解决回调函数嵌套问题\nsetTimeout 被用来模拟一个耗时 2 秒的异步操作。当这个异步操作完成后（即 2 秒后），resolve 被调用，并传递了字符串 '上海市' 作为参数。这会导致 Promise 对象 p 的状态变为 fulfilled，并且 '上海市' 这个值会被传递给 p.then 中注册的回调函数，并被打印出来。\n/** * 目标：掌握Promise的链式调用 * 需求：把省市的嵌套结构，改成链式调用的线性结构 */ // 1. 创建Promise对象 const p = new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { resolve(\u0026#39;上海市\u0026#39;) }, 2000) }) // 获取省份名称 const p2 = p.then(result =\u0026gt; { console.log(result) // 上海市 // 3， 创建Promise对象 模拟请求城市名字 return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { resolve(result + \u0026#39;上海市\u0026#39; + \u0026#39;城市\u0026#39;) }, 2000) }) }) // 获取城市名字 p2.then(result =\u0026gt; { // 这个result里面是 上一个resolve中传递进来的参数 console.log(result) }) // 会发现 p 和 p2 并不全等,就意味着then()返回一个新的对象 console.log(p2 === p) 总结：\n什么是 Promise 的链式调用？\n使用 then()返回新的Promise对象，一直串联下去\nthen 回调函数中， return 的值会传给哪里？\n传给then函数生成的新 Promise对象\nPromise 链式调用 解决了 回调函数嵌套问题\n4. async函数和await 1. 定义 async() 使用async关键字声明的函数。async函数是AsyncFunction构造函数的实例，并且其中允许使用await关键字。async和await关键字让我们可以使用一种更简洁的方式写出基于Promise的异步行为，而无需刻意地链式调用promise\n2. 案例 async function getDefaultArea(){ const pObj = await axios({url:\u0026#39;http://hmajax.itheima.net/api/province\u0026#39;}) const pname = pObj.data.list[0] const cObj = await axios({url:\u0026#39;http://hmajax.itheima.net/api/city\u0026#39;,params:{pname}}) const cname = cObj.data.list[0] const aObj = await axios({url:\u0026#39;http://hmajax.itheima.net/api/city\u0026#39;,params:{pname,cname}}) const aname = aObj.data.list[0] document.querySelector(\u0026#39;.province\u0026#39;).innerHTML = pname document.querySelector(\u0026#39;.city\u0026#39;).innerHTML = cname document.querySelector(\u0026#39;.area\u0026#39;).innerHTML = aname } getDefaultArea() 3. 步骤 概念： 在 async 函数内，使用await关键字取代then函数，等待获取promise对象成功状态\nasync 修饰函数，使普通函数变为异步函数 await 后面增加异步任务 await 后面成功的结果 赋给 左边的变量 5. async函数和await 捕获错误 1. try\u0026hellip;catch ​ 一旦在try这个代码块中出现错误，下面的函数都无法执行\nasync function getDefaultData() { try { // 1. try 可能产生错误的代码 const pObj = await axios({ url: \u0026#39;http://hmajax.itheima.net/api/province\u0026#39; }) const pname = pObj.data.list[0] const cObj = await axios({ url: \u0026#39;http://hmajax.itheima.net/api/city\u0026#39;, params: { pname } }) const cname = cObj.data.list[0] const aObj = await axios({ url: \u0026#39;http://hmajax.itheima.net/api/area\u0026#39;, params: { pname, cname } }) const aname = aObj.data.list[0] document.querySelector(\u0026#39;.province\u0026#39;).innerHTML = pname document.querySelector(\u0026#39;.city\u0026#39;).innerHTML = cname document.querySelector(\u0026#39;.area\u0026#39;).innerHTML = aname } catch (error) { // 2. 接着调用catch块，接收错误信息 // 如果try某行代码报错后，try中剩余的代码不会执行 cosole.dir(error.response.data.message) } } 6. 事件循环 (EventLoop) 1. 概念 JavaScript 有一个__基于事件循环的并发模型__，事件循环负责执行代码、收集和处理事件以及执行队列中的子任务。这个模型与其他语言中的模型截然不同，比如C和Java\n2. 原因 JavaScript单线程（某一刻只能执行一行代码），为了让耗时代码不阻塞其他代码运行，设计了事件循环模型\n3. 执行过程 console.log(1) // 调用栈 setTimeout(()=\u0026gt;{ console.log(2) },0) // 宿主环境 console.log(3) setTimeout(()=\u0026gt;{ console.log(4) },2000) console.log(5) // 控制台输出： 1 3 5 2 4 还是看一下老师的视频讲解，比较清晰。大致步骤是：普通的非异步函数（立即执行函数）在调用栈内执行；异步函数在宿主环境（浏览器）中等待执行并加入任务队列，如果调用栈内任务执行完毕， 会循环反复的查找任务队列的回调函数执行。\n\u003c!DOCTYPE HTML\u003e 4. 总结 什么是事件循环？\n执行代码和收集异步任务，在调用栈空闲时，反复调用任务队列里回调函数执行机制\n为什么有事件循环？\nJavaScript 是单线程，为了不阻塞JS引擎，设计执行代码的模型\nJavaScript 内代码如何执行？\n执行同步代码，遇到异步代码交给宿主浏览器环境执行\n异步有了结果后，把回调函数放入任务队列排队\n当调用栈空闲后，反复调用任务队列里面的回调函数\n7. 宏任务与微任务 ES6 之后引入Promise对象，让JS引擎也可以发起异步任务\n异步任务分为：\n宏任务： 由浏览器环境执行的异步代码 微任务：由 JS 引擎环境执行的异步代码 任务（代码） 执行所在环境 JS 脚本执行事件 (script) 浏览器 setTimeour/setInterval 浏览器 AJAX 请求完成事件 浏览器 用户交互事件等等 浏览器 Promise对象.then() JS引擎 Promise 本身是同步的，而then 和 catch 回调函数是异步的\nconsole.log(1) setTimeout(()=\u0026gt;{ console.log(2) },0) const p 1. 总结 什么是宏任务？\n浏览器执行的异步代码\n例如： JS 执行脚本事件 setTimeout/setInterva，AJAX请求完成事件，用户交互事件等等\n什么是微任务？\nJS 引擎执行的异步代码\n例如： Promise对象.then() 的回调\nJavaScript 内部代码如何执行？\n执行第一个script脚本事件宏任务里面的同步代码\n遇到宏任务/微任务 交给宿主环境（浏览器/JS引擎），执行后的回调函数分别放在 【微任务队列/宏任务队列】\n当执行栈空闲时，清空微任务队列，再执行下一个宏任务\u0026hellip;.\n8. Promise.all 静态方法 1. 概念： 合并多个Promise对象，等待所有同时成功完成（或某一个失败），做后续逻辑\nconst p = Promise.all([Promise对象, Promise对象, ...]) p.then(result =\u0026gt; { // result 结果：[Promise对象成功结果, Promise对象成功结果, ...] }).catch(error =\u0026gt; { // 失败的promise对象 抛出的异常 }) 补充 验证码流程 1. token 访问权限令牌，本质是一串字符串\n创建： 正确登录后，由后端签发返回 作用：判断是否有登录状态等，控制访问权限 注意： 前端智能判断 token 是否存在，而后端才能判断token的有效性\n","permalink":"https://jingyiwu-codespace.github.io/zh/posts/tech/ajax/","summary":"axios,API, XMLHttpRequest, asyn, await, Promise, EventLoop,","title":"学习：AJAX "},{"content":"Outlet of Mood ","permalink":"https://jingyiwu-codespace.github.io/zh/msg/","summary":"Outlet of Mood","title":"🧸 留言板碎碎念 "},{"content":"Day1 1. 作用域 了解作用域对程序执行的影响及作用域链查找机制。使用闭包函数 创建隔离作用域避免全局变量污染\n作用域 (scope) 规定了变量能够被访问的 “范围”， 离开了这个“范围”变量便不能访问\n1.1 局部作用域 函数作用域 ：\n在函数内部声明的变量只能在函数内部被访问，外部无法直接访问\na. 函数内部声明的变量，在函数外部无法被访问\nb. 函数的参数也是函数内部的局部变量\nc. 不同函数内部声明的变量无法访问\nd. 函数执行完毕后，函数内部的变量实际被清空了\n块作用域：\n在JavaScript中使用{ }包裹的代码称为代码块，代码块内部声明的变量外部将 [有可能] 无法被访问（因为var是全局变量）\na. let 声明的变量会产生块作用域, var不会产生作用域\nb. const 声明的敞亮也会产生块作用域\nc. 不同代码块之间的变量无法相互访问\nd. 推荐使用let 或 const\n1.2 全局作用域 \u0026lt;script\u0026gt; 标签 和 .js 文件的 [ 最外层 ] 就是所谓的全局作用域，在此声明的变量在函数内部也可以被访问。\n全局作用域中声明的变量，任何其他作用域都可以被访问\n为 window 对象动态添加的属性默认也是全局的，不推荐!! 函数中未使用任何关键词声明的变量为全局变量，不推荐!! 尽可能少的声明全局变量，防止全局变量污染 1.3 作用域链 作用域链本质上是底层的变量查找机制\n函数被执行时，会优先查找当前函数作用域中查找变量 如果当前作用域查找不到会依次逐级查找父级作用域直到全局作用域 总结：\n嵌套关系的作用域串联起来形成了作用域链 相同作用域链按照从小到大的规则查找变量 子作用域能够访问作用域，父级作用域无法访问子级作用域 1.4 垃圾回收机制 垃圾回收机制（Garbage Collection）\nJS 中内存的分配和回收都是自动完成的，内存在不使用的时候会被垃圾回收器自动回收\n1.4.1 内存的生命周期 内存分配： 当我们声明变量、函数、对象的时候，系统会自动为他们分配内存 内存使用：读写内存，也就是使用变量、函数等等 内存回收：使用完毕，由垃圾回收器自动回收不再使用的内存 注意：\n全局变量一般不会被回收（关闭页面回收） 一般情况下局部变量的值，不用会被自动回收掉 1.4.2 内存泄漏 程序中分配的内存由于某种原因程序未释放或无法释放叫内存泄漏\n1.5 垃圾回收机制算法说明 1. 堆/栈的空间分配 栈 （操作系统）：由操作系统自动分配释放函数的参数值、局部变量、基本数据类型放到栈里面 堆 （操作系统）：一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收。复杂数据类型放在堆内。（数组、对象都在堆内） 2. 垃圾回收算法 a. 引用计数法 IE采用的引用计数算法，定义“内存不再使用”，就是看一个对象是否有指向它的引用，没有引用就回收对象。\n跟踪记录被引用的次数 如果被引用了一次，那么记录次数1，多次引用会累加 ++ 如果减少一个引用就减1 \u0026ndash; 如果引用次数是0，则释放内存 缺点\n嵌套引用 （循环引用） 如果两个对象相互引用，尽管他们已不再使用，垃圾回收器不会进行回收，导致内存泄漏 funcion fn(){ let o1 = {} let o2 = {} o1.a = o2 o2.a = o1 return \u0026#39;引用计数无法回收\u0026#39; } fn() // 他们的引用次数永远不会为0，这样相互引用会导致内存泄漏 // 普通 const arr = [1,2,3,4] arr = null let person = { age : 18, name: \u0026#39;佩奇\u0026#39; } let p = person person = 1 p = null b. 标记清除法 (常用) 标记清除算法将“不再使用的对象”定义为“无法达到的对象” 从根部（在JS中就是全局对象）出发定时扫描内存中的对象。凡是能从根部到达的对象，都还是需要使用 无法由根部出发触及到的对象标记为不再使用，稍后进行回收 1.6 闭包 closure 1. 简单理解： 闭包 = 内存函数+外层函数的变量 上案例：\nfunction outer(){ const a = 1 function f(){ console.log(a) // 内部函数使用外层函数的变量, 二者捆绑在一起 } f()// 调用一下，不然没使用函数 } outer() 2. 闭包基本格式 外部可以访问函数内部的变量. （正常情况下内部变量为局部变量，不能使用） function outer(){ let a = 10 function fn(){ console.log(a) } return fn // 返回一个函数 } outer() // 所以outer() === fn === function fn(){} // 新增一个外部函数,fun()可以直接输出outer内部的值 // 外层函数使用内部函数的变量 const fun = outer() fun() 3. 闭包应用 实现数据私有\n// 非闭包 let i = 0 function fn(){ i++ console.log(`函数被调用${i}`) // 这时候 i是全局变量，容易被修改， // 太像java的getter setter方法了 } // 闭包版 function count(){ let i = 0 function fn(){ i++ console.log(`函数被调用${i}`) } return fn } const fun = count() // 全局变量，当页面关闭时才回收，引用count()中的fn()函数，不会回收 // 这时没有人可以影响函数中的i值，但是闭包也存在内存泄漏的风险 总结：\n怎么理解闭包？\n闭包 = 内层函数 + 外层函数的变量\n闭包的作用？\n封闭数据，实现数据私有，外部也可以访问函数内部变量\n闭包很有用，因为它允许将函数与其操作的某些数据（环境）关联起来\n闭包的问题？\n内存泄漏\n变量提升 变量提升是JavaScript中比较 奇怪 的现象，允许在变量声明之前被访问 (仅存在于var声明变量)\n代码执行前，检查当前作用域下，所有var声明的变量，他会把var声明的所有变量提到 当前作用域的最前面。但是!!! 只提升声明不提升赋值!!!\nconsole.log(num + \u0026#39;件\u0026#39;) var num = 10 // undefined // 所以上方两行代码 等于以下代码 var num console.log(num +\u0026#39;件\u0026#39;) 注意：\n变量在未声明就被访问时，会报错 变量在var声明之前被访问，变量值为undefined let/const声明的变量不存在变量提升 变量提升出现在相同作用域中 实际开发中推荐先声明再访问变量 2. 函数进阶 1. 函数提升 函数提升 和 变量提升有些类似\n可以将函数声明提升到当前作用域的前面，只提升函数声明 function fn(){ console.log (\u0026#39;函数提升\u0026#39;) } fn() // 两种情况都一样 fn() function fn(){ console.log (\u0026#39;函数提升\u0026#39;) } // 但是这种形式 不一样！！函数表达式(赋值),函数表达式必须先声明赋值 再调用，否则报错 fun() var fun = function fn(){ console.log (\u0026#39;函数提升\u0026#39;) } 总结：\n函数提升能够使函数的声明调用更灵活 函数表达式不存在提升的现象 函数提升出现在相同的作用域中 2. 函数参数 1. 动态参数 arguments 是函数内部内置的伪数组变量，包含了调用函数时传入的所有实参\narguments 是一个伪数组，只存在于函数中 arguments 的作用是动态获取函数的实参 可以通过for循环一次得到传递过来的实参 // 不管用户传入几个参数，都要接受 function getSum(){// 不知道用户传多少参数 // arguments 动态参数 只存在函数里 // arguments 是伪数组 console.log(arguments) let sum = 0 for (let i = 0; i\u0026lt;argument.length; i++){ sum+=arguments[i] } return sum } getSum (2,3,4) 2. 剩余参数 剩余参数允许我们将一个不定数量的参数表示为一个数组 ...是语法符号，置于最末函数形参之前，用于获取多余的实参 借助... 获取的剩余实参，是个真数组 开发中，提倡多使用剩余实参 function getSum(...arr){ // ... 就是剩余参数的语法符号 arr随便写 console.log(arr) } getSum(1,2,3) // 第二种用法 function getSum(a,b, ...arr){ // ... 就是剩余参数的语法符号 arr随便写 console.log(arr) // arr = 3 } getSum(1,2,3) 补充：\n展开运算符（不要和剩余参数搞混）\n展开运算符 (\u0026hellip;) 讲一个数组进行展开\n一个在函数里，一个在数组/对象里\u0026hellip;\nconst arr = [1,4,5,8,2] // 数组 对象都能用 console.log(...arr) //1 4 5 8 2 不会修改原数组\n运用场景，数组最值\nconsole.log(Math.max(...arr))\n运用场景，合并数组\nconst arr2 = [3,4,5] // 合并数组 const arr = [...arr1, ...arr2] 3. 箭头函数 目的： 引入箭头函数可以使用更简短的函数写法并且不绑定this,箭头函数的语法比函数表达式更简洁\n使用场景： 箭头函数更适用于本来需要匿名函数的地方\n1. 基本语法 语法1 // 普通函数 const fn = function(){ console.log(\u0026#39;我是普通函数\u0026#39;) } fn() // 箭头函数 const fn = () =\u0026gt; { console.log(\u0026#39;我是普通函数\u0026#39;) } fn()\t语法2: 只有一个参数可以省略小括号\n//普通函数 const fn = function(x){ return x+x } //箭头函数 const fn = x =\u0026gt;{ return x+x } console.log(fn(1)) 语法3: 如果函数体只有一行代码，可以写到一行上，省略大括号，并且无需写return直接放回值\n// 普通函数 const fn = function(x,y){ return x+y } console.log(fn(1,2)) //3 // 箭头函数 const fn = (x,y) =\u0026gt; x+y console.log(fn(1,2)) //3 实际中的写法\nconst form = document.querySelector(\u0026#39;form\u0026#39;) form.addEventListener(\u0026#39;click\u0026#39;,ev =\u0026gt; ev.preventDefault()) 语法4: 加括号的函数体返回对象字面量的表达式\nconst fn1 = uname =\u0026gt; ({uname: uname}) console.log(fn1(\u0026#39;pink老师\u0026#39;)) 总结 箭头函数属于表达式函数，因此不存在函数提升 箭头函数只有一个参数时可以省略圆括号( ) 箭头函数的函数体只有一行代码时，可以省略花括号{}, 并自动作为返回值被返回 加括号的函数体返回对象字面量表达式 uname =\u0026gt;({uname:uname}) 2. 箭头函数参数 普通函数有arguments动态参数 箭头函数没有arguments动态参数，但是有剩余参数 ...args const getSum = (...args) =\u0026gt; { let sum = 0 for (let i = 0; i\u0026lt;args.length;i++){ sum += args[i] } return sum // 注意函数体有多行代码时需要return // 大括号也不能省 } console.log(getSum(1,2,3)) 3. 箭头函数 this 以前this的指向：谁调用这个函数，this就指向谁\nconsole.log(this) //此处为window const sayHi = function({ cnosole.log(this) // 普通函数指向调用者，此处为window }) btn.addEventListener(\u0026#39;click\u0026#39;,function(){ console.log(this) // 当前this，指向btn }) 箭头函数不会创建自己的this,只会从自己的作用域链的上一层沿用this. （说简单点，父亲的this就是箭头函数的this ）\nconst fn = ()=\u0026gt;{ console.log(this) //window } // 因为箭头函数没有this!!, 所以会调用父亲window的this 对象方法箭头函数this\nconst obj = { uname : \u0026#39;pink老师\u0026#39;， sayHi : () =\u0026gt; { console.log(this) //this指向谁？window } } obj.sayHi() // 因为sayHi()方法中没有this，沿用上一级obj的this， window 调用obj，所以this指向window ​\t复杂一点的案例\nconst user = { name: \u0026#39;小明\u0026#39;, sayHi: function(){ // 注意这是普通函数，this指向函数的调用者 console.log(this) //user let i = 10 const count = () =\u0026gt;{ console.log(this) //user } count() // user // 因为箭头函数的作用域中没有this，所以指向上层作用域的this } } 在开发中 【 使用箭头函数前需要考虑函数中的this值 】，事件回调函数使用箭头函数时，this为全局的window，因此DOM事件回调函数为了简便，不推荐使用箭头函数\n// DOM 节点 const btn = document.querySelector(\u0026#39;.btn\u0026#39;) // 箭头函数，此时this指向window btn.addEventListener(\u0026#39;click\u0026#39;,() =\u0026gt;{ console.log(this) }) // 普通函数，此时this指向了DOM对象 btn.addEventListener(\u0026#39;click\u0026#39;,function(){ console.log(this) }) 总结：\n箭头函数里面有this吗？\n箭头函数不会创建自己的this, 它只会从自己的作用域链的上一层沿用this\nDOM 事件回调函数推荐使用箭头函数吗？\n不推荐，特别是需要用到this的时候\n事件回调函数使用箭头函数时，this为全局的window\n3. 解构赋值 1. 数组解构 数组解构是将数组的单元值快速批量赋值给一系列变量的简洁语法\n引入 // 普通写法 const arr = [100,60,80] const max = arr[0] const min = arr[1] const avg = arr[2] console.log(max) console.log(min) console.log(avg) // 解构赋值版本 const [max, min, avg] = [100, 60, 80] console.log(max) console.log(min) console.log(avg) 基本语法 赋值运算符 = 左侧的 [] 用于批量声明变量，右侧数组的单元值被赋值给左侧的变量\n变量的顺序对应数组单元值的位置依次进行赋值操作\n// 普通的数组 const arr = [1,2,3] // 批量声明变量 a,b,c // 同时将数组单元值1，2，3 依次赋值给变量a b c const [a,b,c] = arr console.log(a) //1 console.log(b) //2 console.log(c) //3 // 再来一个 const [max,min,avg] = arr 交换变量应用\nlet a = 1 let b = 2; //必须加分号 [b,a] = [a,b] 变量多，单元值少的情况\nconst [a,b,c,d] = [1,2,3] console.log(a) //1 console.log(b) //2 console.log(c) //3 console.log(d) //undefined 变量少，单元值多的情况\n使用剩余参数解决变量少，单元值多的情况\nconst [a,b,c] = [1,2,3,4,5] console.log(a) //1 console.log(b) //2 console.log(c) //3 // 剩余参数 const [a,b,...c] = [1,2,3,4] console.log(a) //1 console.log(b) //2 console.log(c) //[3,4] 真数组 // 防止undefined传递,给了默认参数 const [a = 0,b=0] = [1,2] const [a = \u0026#39;手机\u0026#39;, b=\u0026#39;华为\u0026#39;] = [\u0026#39;小米\u0026#39;] console.log(a) //小米 console.log(b) //华为 按需导入复制\nconst [a,b,,d] = [1,2,3,4] console.log(a) //1 console.log(b) //2 console.log(d) //4 支持多维数组解构\nconst arr = [1,2,[3,4]] console.log(arr[0]) //1 console.log(arr[1]) //2 console.log(arr[2]) //[3,4] console.log(arr[2][0]) //[3] // 解构 const [a,b,c] = [1,2,[3,4]] const [a,b,[c,d]] = [1,2,[3,4]] 注意： JS 必须加分号的情况;\n立即执行函数 (function t(){})(); // 或者 ;(function t(){})() 数组解构 // 数组开头的，特别是前面有语句的一定要注意加分号 ;[b,a] = [a,b] 总结：\n数组解构赋值的作用是什么？\n将数组的单元值快速批量赋值给一系列变量的简洁语法\nJS 前面有有哪两种情况必须要加分号?\n立即执行函数 和 数组开头的情况\n变量的数量大于单元值数量时，多余变量将被赋值为undefined\n变量的数量小于单元值数量时，可以通过剩余参数获取剩余单元值，但只能置于最末位\n2. 对象解构 对象解构是将对象属性和方法快速批量赋值给一系列变量的简洁语法\n1. 基本语法 赋值运算符 = 左侧的{}用于批量声明变量，右侧对象的属性值将赋值给左侧的变量 对象属性的值将被赋值给与属性名相同的变量 注意解构的变量不要和外面的变量名冲突，否则报错 对象中找不到与变量名一致的属性时变量为undefined const obj = { uname : \u0026#39;pink老师\u0026#39;, age : 18 } // 对象解构 const {uname,age} = { uname : \u0026#39;pink老师\u0026#39;, age : 18 } // 等价于 const uname = obj.name const uname = obj.uname 2. 解构的属性改名 const obj = { uname : \u0026#39;pink老师\u0026#39;, age : 18 } const {uname: username,age} = obj 3. 解构数组对象 const pig = [ { uname: \u0026#39;pig\u0026#39;, age: 18 } ] const[{uname, age}] = pig 4. 多级对象解构 const pig = { name : \u0026#39;佩奇\u0026#39;, family: { mother:\u0026#39;猪妈妈\u0026#39;, father:\u0026#39;猪爸爸\u0026#39;, sister:\u0026#39;乔治\u0026#39;, }, age:6 } const {name, family{mother,father, sister},age} = pig cosole.log(name) cosole.log(mother) cosole.log(father) cosole.log(sister) cosole.log(age) 再来一个案例, 数组+对象\nconst people = [ { name : \u0026#39;佩奇\u0026#39;, family : { mother:\u0026#39;猪妈妈\u0026#39;, father:\u0026#39;猪爸爸\u0026#39;, sister:\u0026#39;乔治\u0026#39; }, age : 6 } ] const[{name,family:{mother,father,sister},age}] = people cosole.log(name) cosole.log(mother) cosole.log(father) cosole.log(sister) cosole.log(age) forEach() 用于调用数组的每个元素，并将元素传递给回调函数。 只遍历数组，不能遍历对象。\n使用场景： 遍历数组的每个元素\n只遍历，不返回数组\n语法 forEach 主要遍历数组，适合于遍历数组对象!! 参数中，当前元素数组item是必须要写的，索引号index可选 被遍历的数组.forEach(function(当前数组元素，当前元素所引号)){ // 函数体 } const arr = [\u0026#39;red\u0026#39;,\u0026#39;green\u0026#39;,\u0026#39;pink\u0026#39;] arr.forEach(function(item, index){ console.log(item) // red green pink console.log(index) // 0，1，2 }) filter() 重点 filter() 方法创建一个新的数组，新数组中元素是通过检查指定数组中符合的所有元素\n使用场景：筛选数组符合条件的元素，并返回筛选之后元素的新数组\n语法 被遍历的数组.filter(function(item,value){ return 筛选条件 }) 也是数组方法，和map()更像，有返回值。\n但是只能return 后面只能写 \u0026gt;=, \u0026lt;=, \u0026lt;, \u0026gt;, =等比较运算符\nconst arr = [10,20,30] const newArr = arr.filter (function(item,index){ console.log(item) console.log(index) return item\u0026gt;=20 // 返回新数组 }) newArr // [20,30] // 箭头函数 简洁版 const newArr = arr.filter(item =\u0026gt; item\u0026gt;=20) Day2 1. 构造函数 1. 深入对象 1. 创建对象的三种方式 1. 对象字面量创建对象 const o = { name: \u0026#39;佩奇\u0026#39; } 2. new const o = new Object() 3. 构造函数 构造函数：是一种特殊的函数，主要用来初始化对象 使用场景：常规的{}语法允许创建一个对象，构造函数可以快速创建多个类似的对象 上案例 function Pig (name, age, gender){ this.name = name this.age = age this.gender = gender } // 创建佩奇对象 const Peppa = new Pig(\u0026#39;佩奇\u0026#39;，6，\u0026#39;女\u0026#39;) const George = new Pig(\u0026#39;乔治\u0026#39;，6，\u0026#39;女\u0026#39;) const Mum = new Pig(\u0026#39;妈妈\u0026#39;，6，\u0026#39;女\u0026#39;) 构造函数语法 命名以大写字母开头 只能用new操作符来执行 说明：\n使用new关键字调用函数的行为被称为实例化 实例化构造函数时没有参数时可以省略() 构造函数内部无需写return, 返回值即为新创建的对象 构造函数内部的return返回的值无效，所以不用写return new Object() new Date() 也是实例化构造函数 4. 实例化的执行过程 创建新的空对象 构造函数this指向新对象 执行构造函数代码，修改this, 添加新的属性 返回新对象 5. 实例成员 通过构造函数创建的对象称为实例对象，实例对象中的属性和方法称为实例成员(实例属性和实例方法)\nfunction Person(name){ // 实例属性 this.name = name // 实例方法 this.sayHi= () =\u0026gt; console.log(\u0026#39;hi!!~~\u0026#39;) } 6. 静态成员 构造函数的属性和方法被称为静态成员 (静态属性和静态方法)\n就是Java的类方法, 以下均为静态成员\nDate.now() Math.PI Math.random()\nfunction Person(name,age){ // code... } // 静态属性 Person.eyes = 2 // 静态方法 Person.breath = function(){ console.log(\u0026#39;走路ing\u0026#39;) // 此时 this 指向Person console.log(this.eyes) } 2. 内置构造函数 JavaScript 中最主要的数据类型 6 种\n字符串、数值、布尔、undefined、null、对象\n1. 基本包装类型 JavaScript 底层完成了将简单数据类型包装为引用数据类型，称为包装类型。神似Java中的拆箱和装箱, 所以像普通字符串可以使用str.length。\n2. 引用类型 1. Object 内置的构造函数，用于创建普通对象\nconst user = new Object() const user = {uname:\u0026#39;pink\u0026#39;,age:18} // 原来使用for..in..遍历 // 现在使用 Object.keys(user) Object 静态方法 !!! 注意 静态方法只有构造函数Object可以调用!!!\n静态方法或属性 作用 返回值 Object.keys(实例化对象) 获得所有对象的所有键 (包括属性及方法) 数组 Object.values(实例化对象) 获得所有对象的所有值 (包括属性及方法) 数组 Object.assign(新对象, 老对象) 将老对象的内容拷贝给新对象，用于给对象添加属性 对象 // Object.assign() const o = {name:\u0026#39;佩奇\u0026#39;,age:6} Object.assign(o, {gender:\u0026#39;女\u0026#39;}) console.log(o) {name: \u0026#39;佩奇\u0026#39;, age: 6, gender:\u0026#39;女\u0026#39;} 2.Array 内置的构造函数，用于创建数组\nconst arr = new Array (2,5,4) const arr = [2,3,5] //推荐!! 字面量的形式创建数组 数组常见的实例方法 方法 作用 说明 forEach 遍历数组 不返回数组，经常用于查找遍历数组元素 filter 过滤数组 返回新数组，返回的是筛选满足条件的数组元素 map 迭代数组 返回新数组，返回的是处理之后的数组元素，想要使用返回的新数组 reduce 累计器 返回累计处理的结果，用于求和等等 1 .reduce( ) // 基本语法 arr.reduce(function(){}, 初始值) arr.reduce(function(上一次值, 当前值){}, 初始值) // 例子 const arr = [1,5,8] // 没有初始值 const total = arr.reduce(function(prev,current){ return prev + current }) console.log(total) //14 // 有初始值 const total = arr.reduce(function(prev,current){ return prev + current },10) //14+10 ==24 // 箭头函数版 arr.reduce((prev,current) =\u0026gt; prev + current,10) 参数：\n如果有起始值，则把起始值累加到里面\nreduce 执行过程\n如果没有起始值，则上一次值以数组的第一个元素的值 每一次循环，把返回值作为下一次循环的上一次值 如果有起始值，则起始值作为上一次值 如果是对象数组，初始值必须设置为0 const arr = [{ name: \u0026#39;张三\u0026#39;, salary: 10000 }, { name: \u0026#39;李四\u0026#39;, salary: 10000 }, { name: \u0026#39;王五\u0026#39;, salary: 20000 }, ] const salaries = Object.values(arr) console.log(salaries) const total = salaries.reduce(function (pre, next) { console.log(pre) return pre + next.salary }, 0) console.log(total) 2. 其他常见方法 记不住的查一下mdn网站\n方法 作用 说明 语法 join() 为数组元素拼接字符串 返回字符串 find() 查找元素 返回符合条件的第一个数组元素值，如果没有符合条件的则返回undefined arr.find(callback, [, thisArg])callback就是回调函数，就是function(){} every() 检测数组所有元素是否都符合指定条件 如果所有元素都通过检测返回true; 否则返回false; 若收到一个空数组，在此方法下一切情况都会返回true some() 检测数组中的元素是否满足指定条件 如果数组中有元素都通过检测返回true; 否则返回false concat() 合并两个数组 返回生成的新数组 sort() 对原来的数组单元值排序 splice() 删除或替换原来的数组元素 reverse() 反转数组 findIndex() 查找元素的索引值 Array. from() 将伪数组转换为真数组!! 静态方法 返回一个新的真数组 判定伪数组可以使用pop()方法，伪数组不能使用 // find() const arr = [\u0026#39;red\u0026#39;,\u0026#39;blue\u0026#39;,\u0026#39;green\u0026#39;] const re = arr.find(function(item){ return item === \u0026#39;blue\u0026#39; }) console.log(re) // find()使用场景 const arr = [ { name :\u0026#39;小米\u0026#39;， price: 1999 }, { name:\u0026#39;华为\u0026#39;， price: 3999 }, { name :\u0026#39;小米\u0026#39;， price: 1999 } ] arr.find(function(item){ item.name == \u0026#39;小米\u0026#39; return item }) // 箭头函数版 arr.find (item =\u0026gt; item.name == \u0026#39;小米\u0026#39;) // every() [12,5,8,130,44].every(x =\u0026gt; x\u0026gt;=10 ); false [12,130,44].every(x =\u0026gt; x\u0026gt;=10); true // some() 和 every()差不多，类似于\u0026amp;\u0026amp; 和 ||的区别 3. 包装类型 之所以基本数据类型具有对象特征，是因为字符串、数值、布尔类型数据是JavaScript底层使用Object构造函数包装形成的，被称为包装类型\n1.String 属性/方法 名称 描述 属性 .length 获取字符粗汉长度 方法 .split(\u0026lsquo;分隔符\u0026rsquo;) 将字符串拆分称数组 方法 .substring( 需要截取的第一个字符的索引, [结束的索引号]) 用于字符串截取 方法 startsWith( 搜索字符串 [, 检测位置索引号])， 返回布尔值 检测是否以某字符开头 方法 includes(搜索的字符串[, 检测位置索引号])， 返回布尔值。区分大小写!! 检测一个字符串是否包含在另一个字符串中 // str.split() 和 arr.join() 作用相反 const str = \u0026#39;pink, red\u0026#39; const arr = str.split(\u0026#39;,\u0026#39;) console.log(arr); // [\u0026#39;pink\u0026#39;, \u0026#39;red\u0026#39;] const str1 = \u0026#39;2022-4-8\u0026#39; const arr1 = str1.split(\u0026#39;-\u0026#39;) console.log(arr1) //[\u0026#39;2022\u0026#39;,\u0026#39;4\u0026#39;,\u0026#39;8\u0026#39;] // str.substring() const anyString = \u0026#39;Mozilla\u0026#39; anyString.substring(1) //ozilla // str.startsWith(searchString [,position]) const str = \u0026#34;To be, or not to be, that is a question\u0026#34; str.startsWith(\u0026#39;To be\u0026#39;) //True str.startsWith(\u0026#39;not to be\u0026#39;) //False str.startsWith(\u0026#39;not to be\u0026#39;,10) //True // str.includes() 方法区分大小写 \u0026#39;Blue Whale\u0026#39;.includes(\u0026#39;blue\u0026#39;) // False str.includes(\u0026#39;To be\u0026#39;,1) // False 2.Number 属性/方法 名称 描述 方法 .toFixed() 设置保留小数位的长度 方法 String(num)或者.toString() 转换为字符串 const price = 23.345 // 保留两位小数，四舍五入 price.toFixed(2) 23.35 Day3 面向过程编程： 分析出解决问题所需要的步骤，然后用函数把步骤逐步实现，使用的时候再依次调用\n面向对象编程：把事务分解成一个对象，由对象之间分工合作。以对象功能来划分问题，而不是步骤\n1. 面向对象编程 (OOP) 在面向对象程序开发思想中，每一个对象都是功能中心，具有明确的分工\n面向对象编程具有灵活、代码可复用、容易维护和开发的优点，更适合多人合作的大型软件项目。\n面向对象具有：\n-\u0026gt; 封装性\n-\u0026gt; 继承性\n-\u0026gt; 多态性\n面向过程编程 vs 面向对象编程 名称 优点 缺点 面向过程编程 性能比面向对象高，适合与硬件联系很紧密，如单片机就采用面向过程编程 没有面向对象易维护、易复用、易扩展 面向对象编程 易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特征。可以设计出低耦合的系统，使系统更加灵活、更加易于维护 性能比面向过程低 2. 构造函数 封装是面向对象思想中比较重要的一部分，JS面向对象可以通过构造函数实现封装 将变量和函数组合到了一起并能通过this实现数据的共享，构造函数创建出来的实例对象之间彼此互不影响 但是会出现浪费内存的问题，比如sing()方法，每一个对象都会创建 function Star(uname, age){ this.uname = uname this.age = age this.sing = function(){ console.log(\u0026#39;我会唱歌\u0026#39;) } } const ldh = new Star(\u0026#39;刘德华\u0026#39;，55) const zxy = new Star(\u0026#39;张学友\u0026#39;，55) 为了避免内存浪费的出现，引入原型知识点\n3. 原型 1. 什么是原型 构造函数通过原型分配的函数是所有对象所共享的 JavaScript每个构造函数都有一个prototype属性，指向另一个对象，所以我们也称原型对象 原型对象可以挂载函数，对象实例化不会多次创建原型上的函数，从而节约内存 将不变方法，直接定义在prototype对象上，这样所有对象的实例就可以共享这些方法 构造函数和原型对象中的this都指向实例化的对象 // 公共的属性写到构造函数里 function Star(uname, age){ this.uname = uname this.age = age this.sing = function(){ console.log(\u0026#39;我会唱歌\u0026#39;) } } Star.prototype // 看起来像属性，但是返回值是对象 // 公共的方法写到了原型对象身上 Star.prototype.sing = function(){ console.log(\u0026#39;我会唱歌\u0026#39;) } const ldh = new Star(\u0026#39;刘德华\u0026#39;，55) const zxy = new Star(\u0026#39;张学友\u0026#39;，55) ldh.sing() zxy.sing() //此时 ldh.sing === zxy.sing //true 总结： 原型是什么？\n一个对象，我们称 prototype 为原型对象\n原型的作用是什么？\n共享方法\n可以把那些不变的方法，直接定义在`prototype对象上\n构造函数和原型里面的this指向实例化对象\n案例： 给数组对象添加扩展方法， 求和 与 最大值\n// 数组扩展方法 // 最大值, 添加方法 const arr = [1,2,3] Array.prototype.max = function(){ // 展开运算符 return Math.max(...this) } arr.max() // 求和 Array.prototype.sum = function(){ return this.reduce((prev,item)=\u0026gt;{prev+item},0) } 2. constructor 属性 每一个原型对象都有一个constructor属性\n1. 定义 该属性指向该原型对象的构造函数Star.prototype.constructor\nfunction Star(){} // Star已经是构造函数了，肯定有prototype的属性了 Star.prototype.contructor // prototype对象有constructor的属性，指回Star构造函数 2. 使用场景 如果有多个对象方法，我们可以给原型对象采取对象形式赋值。但是这样就会覆盖构造函数原型对象原来的内容，意味着修改后的原型对象constructor就不再指向当前的构造函数。此时我们可以在修改后的原型对象中，添加一个contructor指向原来的构造函数。\nfunction Star(name){ this.name = name } // 以对象的形式批量添加原型方法 Star.prototype = { // 需要手动添加constructor，指回Star构造函数 constructor: Star, sing:function(){console.log(\u0026#39;唱歌\u0026#39;)}, dance:function(){console.log(\u0026#39;跳舞\u0026#39;)} } // 这样的话，prototype中的constructor的属性就会被覆盖 总结：\n​\tconstructor 属性的作用是什么?\n指向该原型对象的构造函数 3. 对象原型 实例对象都会有一个属性 __proto__指向构造函数的prototype原型对象，之所以我们对象可以使用构造函数prototype原型对象的属性和方法，就是因为有__proto__原型的存在\n对象原型proto 指向该 构造函数的 原型对象 （对象原型指向原型对象!!）\nfunction Star(){} const ldh = new Star() // 对象原型__proto__指向 该 构造函数的原型对象 console.log(ldh.__proto__) //Star.prototype // 所以!!!!!! ldh.__proto__ === Star.prototype Star.prototype.constructor //是Star // 所以!! ldh.__proto__.constructor === Star 总结：\nprototype 是什么? 哪里来？\n原型对象\n每个构造函数都有原型\nStar.prototype可以挂载相同的方法\nconstructor属性在哪里? 作用是什么？\nprototype原型和对象原型__proto__都指向创建实例对象/原型的构造函数\n__proto__属性在哪里？指向谁？\n在实例对象里面，指向prototype原型\n对象原型指向原型对象, 只读不可以赋值\n4. 原型继承 错误版本!! 会导致混乱 // 将公共类放在原型上 const Person = { eyes: 2, head: 1 } // 女生 构造函数，通过原型继承Person function Women(){} Women.prototype = Person Women.prototype.constructor = Women // 添加女生类的单独的方法，但是会出现将男生类方法一起修改的情况 Women.prototype.say = function(){ console.log(\u0026#34;我是女生，漂亮的女生\u0026#34;) } function Man(){ Man.prototype = Person Man.prototype.constructor = Man } 正确版本，利用继承 // 将Person变成类 (构造函数) function Person(){ eyes: 2, head: 1 } function Woman(){ } // prototype上存一下不变的方法 Woman.prototype = new Person() Woman.prototype.constructor = Woman 5. 原型链 基于原型对象的继承使得不同构造函数的原型对象挂念在一起，并且这种关联的关系是一种链式结构，我们将原型对象的链状结构关系称为原型链\n前提： 只要是对象都有原型 __proto__ 只要是原型对象都具备constructor属性，指回创造原型对象的构造函数 原型链-\u0026gt;查找规则 当访问一个对象的属性(包括方法)时，首先查找这个对象自身有没有该属性。 如果没有就查找它的原型 .__proto 指向prototype原型对象 如果还是没有就查找原型对象的原型 依次类推一直找到Object为止(null) .__proto__对象原型的意义在于为对象成员查找机制提供一个方向或路线 可以使用instanceof运算符来检测构造函数prototype属性是否出现在某个实例对象的原型链上 instance ldh instanceof Person // true ldh instanceof Object // true ldh instanceof Array // false [1,2,3] instanceof Array // true Array instanceof Object // 万物皆对象 Day4 1. 深浅拷贝 首先浅拷贝和深拷贝只针对于引用类型\n堆中永远存储引用类型，值类型可以存在堆也可以存在栈\n1. 浅拷贝 拷贝的是地址， 只拷贝最外面的一层。像是嵌套对象还是指向同一个地址。所以单层没问题，如果出现嵌套，就会出现修改原数据的情况。\n拷贝对象 Object.assign() {...obj} 拷贝数组 Array.prototype.concat() [...arr] const obj = { uname: \u0026#39;pink\u0026#39;, age: 18 family:{ // 这一层还是指向同一个地址 baby:\u0026#39;pink\u0026#39; } } const o = {} Object.assign(o,obj) // 浅拷贝 const o = {...obj} // 浅拷贝的另一种形式 总结：\n直接赋值和浅拷贝有什么区别？\n直接赋值的方法，只要是对象，都会相互影响，因为是直接拷贝对象栈里面的地址\n浅拷贝如果是一层对象，不相互影响，如果出现多层对象拷贝还是会相互影响\n浅拷贝如何理解？\n拷贝对象之后，里面的属性值是简单数据类型直接拷贝值 如果属性值是引用数据类型则拷贝的是地址 2. 深拷贝 首先浅拷贝和深拷贝只针对引用类型\n深拷贝：拷贝的是对象，不再是地址\n三种深拷贝方法 1. 函数递归 如果一个函数在内部自己调用自己，此函数就是递归函数\n函数内部自己调用自己，这个函数就是递归函数 递归函数的作用和循环效果类似 由于递归很容易发生“栈溢出”错误 (stack overflow), 所以必须要加退出条件return let i =1 function fn(){ console.log(`这是第${i}次`) if (i \u0026gt;= 6){ // 退出条件 return } i++ fn() // 自己调用自己 } 条件：\n自己调用自己 有终止条件 // 为了更好的递归，利用递归函数实现setTimeout模拟setInterval效果 function getTime(){ document.querySelector(\u0026#39;div\u0026#39;).innerHTML = new Date().toLocalString() setTimeout(getTime, 1000) // 自己调用自己 } getTime() 浅拷贝案例：\nconst obj = { uname:\u0026#39;pink\u0026#39;, age:18 hobby:[\u0026#39;乒乓球\u0026#39;,\u0026#39;足球\u0026#39;] } const o = {} //拷贝函数 本质是浅拷贝 function deepCopy(newObj, oldObj){ for(let k in oldObj){ // k 属性名 uname oldObj[k] 属性值18 // newObj[k] === o.uname newObj[k] = oldObj[k] } } deepCopy(o,obj) //函数调用 两个参数 // o-\u0026gt;新对象 // obj旧对象 o.age = 20 // 现在对象o改变，也不会影响obj o.hobby[0] = \u0026#39;篮球\u0026#39; //还是会修改obj，所以本质!!! 是浅拷贝!! 递归深拷贝\n深拷贝的新对象不会影响浅拷贝的旧对象 使用递归实现深拷贝 如果遇到数组形式，加入instanceof判断 如果遇到对象形式，再次利用递归解决对象 先Array 后Object const obj = { uname:\u0026#39;pink\u0026#39;, age:18 hobby:[\u0026#39;乒乓球\u0026#39;,\u0026#39;足球\u0026#39;] } const o = {} //拷贝函数 注意深拷贝数组需要在新对象中重新new function deepCopy(newObj, oldObj){ for(let k in oldObj){ if (oldObj[k] instanceof Array){ newObj[k] = [] // 调用递归 deepCopy(newObj[k],oldObj[k]) } else{ // k 属性名 uname oldObj[k] 属性值18 // newObj[k] === o.uname newObj[k] = oldObj[k] } } } deepCopy(o,obj) //函数调用 两个参数 // o-\u0026gt;新对象 // obj旧对象 o.age = 20 // 现在对象o改变，也不会影响obj o.hobby[0] = \u0026#39;篮球\u0026#39; 2. cloneDeep/lodash Loads 库 _.cloneDeep(value)\n\u0026lt;script src = \u0026#39;./lodash.min.js\u0026#39;\u0026gt;\u0026lt;/script\u0026gt; const obj = { uname: \u0026#39;pink\u0026#39;, age: 18, hobby: [\u0026#39;乒乓球\u0026#39;,\u0026#39;足球\u0026#39;], family:{ baby:\u0026#39;小pink\u0026#39; } } const o = _.cloneDeep(obj) // 深拷贝！ 3. JSON.stringify() const obj = { uname: \u0026#39;pink\u0026#39;, age: 18, hobby: [\u0026#39;乒乓球\u0026#39;,\u0026#39;足球\u0026#39;], family:{ baby:\u0026#39;小pink\u0026#39; } } // 把对象转换为字符串 JSON.stringify(obj) // 再把字符串转换成对象 const o = JSON.parse(JSON.stringify(obj)) // 新对象 // 转换成简单数据类型之后，直接存值，在转换成对象时，重新变成了新对象 总结：\n实现深拷贝的三种方式？\n函数递归\nlodash _cloneDeep\nJSON.stringify()\n2. 异常处理 提升代码健壮性\n1. throw 抛异常 异常处理是指预估代码执行过程中可能发生的错误，然后最大程度的避免错误的发生导致整个程序无法运行\nthrow会直接终止程序\nfunction couter(x,y){ if(!x || !y){ throw \u0026#39;参数不能为空\u0026#39; } } function couter(x,y){ if(!x || !y){ throw new Error(\u0026#39;参数不能为空\u0026#39;) } } 总结：\nthrow 抛出异常信息，程序也会终止执行 throw 后面是错误提示信息 Error 对象配合throw使用，能够设置更详细的错误信息 throw new Error('错误信息') 2. try/catch 捕获异常 通过 try/catch 捕获错误信息\n​\ttry{} 预估的错误代码\n​\tcatch(形参){} 拦截错误信息，使用浏览器参数error.message\n​\tfinally{} 不管程序对不对，一定会执行\nfunction foo(){ try{ // 可能发生错误的代码，写入try模块 const p = document.querySelector(\u0026#39;.p\u0026#39;) p.style.color = \u0026#39;red\u0026#39; } catch (err){ console.log(error.message) // 错误信息 // 拦截错误，提示浏览器提供错误信息，但是不中断程序执行，可以与 throw new Error(\u0026#39;\u0026#39;)配合使用，会中断程序 return // 需要return 中断程序 } finally { // 不管程序对不对，一定会执行的代码 alert(\u0026#39;执行\u0026#39;) } console.log(\u0026#39;如果出现错误，我的语句不会执行\u0026#39;) } 3. debugger 相当于断点的代码版，直接在需要调试的代码上一行写debugger 就行\n3. 处理 this 1. 普通函数 this 指向 普通函数的调用方式决定了 this 的值，谁调用 this指向谁\nconsole.log(this) //this指向window // 普通函数 function sayHi(){ console.log(this) } // 函数表达式 const sayHello = function(){ console.log(this) } // 函数的调用方式决定了 this 的值 sayHi() window.sayHi() // window 调用 setTimeout(function(){ console.log(this) //window },1000) // 也是window， 因为本质是 window.setTimeout() document.querySelector(\u0026#39;button\u0026#39;).addEventListener(\u0026#39;click\u0026#39;,function(){console.log(this)}) // 输出的是button，因为是button调用了函数 const obj = { sayHi:function(){ console.log(this) } } obj.sayHi() 注意：\n普通函数有严格模式，指向undefined\n2. 箭头函数 this 指向 箭头函数中并不存在 this\n箭头函数会默认帮我们绑定外层 this的值，所以在箭头函数中的this值和外层的 this是一样的 箭头函数中的 this引用的是最近作用域中的 this 向外层作用域中，一层一层查找 this，直到有 this的定义 const user = { name: \u0026#39;小明\u0026#39;, walk: ()=\u0026gt;{ console.log(this) } } // 此时对象里没有this，向上层寻找 this 指向window 注意情况：\n在开发中使用箭头函数前需要考虑函数中 this 的值，事件回调函数使用箭头函数时，this 为全局window。因此DOM事件回调函数如果里面需要DOM对象的this，则不推荐使用箭头函数 // DOM 节点 const btn = document.querySelector(\u0026#39;.btn\u0026#39;) // 箭头函数此时 this 指向了window btn.addEventListener(\u0026#39;click\u0026#39;,()=\u0026gt;{ console.log(this) // 由于使用箭头函数，所以此时的this指向window // 因为this绑定外层 }) btn.addEventListener(\u0026#39;click\u0026#39;,function(){ console.log(this) // 普通函数的this则指向调用者 }) 基于原型的面向对象也不推荐采用箭头函数 function Person(){ } // 原型对象上添加箭头函数 Person.prototype.walk = () =\u0026gt; { console.log(\u0026#39;人都是要走路..\u0026#39;) console.log(this); //指向window } const p1 = new Person() p1.walk() // 这个位置注意，面向原型本质是挂载方法，让其他实例在创建之后就能使用，如果使用箭头函数，this无法指向实例对象，而是指向window 总结：\n箭头函数内不存在this,沿用上一级 不适用：构造函数、原型函数、dom事件函数 适用：需要使用上层 this 的地方 3. 改变 this JS 中允许指定函数中 this 的指向，有3个方法可以动态指定普通函数中 this 的指向\n1. call() function.call(thisArg, arg1, arg2, ...)\nthisArg: 在fun函数运行时指定的this值 arg1, arg2: 传递其他参数 返回值就是函数的返回值，因为他就是调用函数 const obj = { uname : \u0026#39;pink\u0026#39; } function fn(x,y){ console.log(this) // window console.log(x+y) } // 使用call方法改变函数指向 fn.call(obj,1,2) // 输出obj函数 和3 2. apply() 使用apply方法调用函数，同时指定被调用函数中的this的值\n​\tfunction.apply(thisArg, [argsArray])\nthisArg: 在 fun函数 运行时指定的this值 argsArray: 传递值，必须包含在__数组__里面 返回值就是函数的返回值，因为他就是调用函数 因此apply主要跟数组有关系，比如Math.max() const obj = { age:18 } function fn(x,y){ console.log(this) // {age: 18} console.log(x+y) } fn.apply(obj,[1,2]) // 18 , 3 // 使用场景： 求数组最大值 const max = Math.max(1,2,3) // 使用Math.max方法 const arr = [100, 44, 77] const max = Math.max.apply(Math, arr) const min = Math.min.apply(Math, arr) // 这个案例写Math和null都可以 const max = Math.max.apply(null, arr) const min = Math.min.apply(null, arr) // 第二种求数组最大值的方法, 扩展运算符 console.log(Math.max(...arr)) 总结：\ncall 和 apply的区别是什么？\n都是调用函数，都能改变 this 指向 参数不一样， apply传递必须时数组 3. bind() 重点 bind( ) 方法不会调用函数。但是能改变函数内部 this 指向\n​\tfunction.bind(thisArg, arg1, arg2, ...)\nthisArg: 在 function 函数运行时指定的 this 值 arg1, arg2: 传递的其他参数 返回值 由指定的 this 值和初始化参数改造的 原函数拷贝 （新函数） 因此当我们只是想改变 this 指向，并不想调用这个函数的时候，可以使用 bind， 比如改变定时器内部的 this 指向 const obj = { age: 18 } function fn(){ console.log(this) } // 1. bind 不会调用函数 // 2. 能改变 this 窒息那个 // 3. 返回值是一个函数，但是这个函数里面的this是更改过的 const fun = fn.bind(obj) fun() // 定时器内部的例子 document.querySelector(\u0026#39;button\u0026#39;).addEventListener(\u0026#39;click\u0026#39;,function(){ // 禁用按钮 this.disabled = true window.setTimeout(function(){ this.disabled = false }.bind(this), 2000) }) call(), apply(), bind() 总结\n相同点\n都可以改变函数内部的 this 指向\n区别点\ncall 和 apply会调用函数，并且改变函数内部this指向\ncall 和 apply传递参数不一样, call 传递参数 arg1, arg2, ...形式， apply则必须是数组形式[arg]\nBind 不会调用函数，可以改变函数内部this指向\n主要应用场景\ncall 调用函数并且可以传递参数\napply 经常与数组有关，比如借助数学对象实现数组最大值最小值\nbind 不调用函数，但是还想改变 this 指向，比如改变定时器内部 this 指向\n4. 防抖 (debounce) 在单位时间内，频繁触发事件，只执行最后一次。 类似王者荣耀回城，只要被打断就需要重新再来\n1. lodash 提供防抖处理 _.debounce(func,[wait = 0],[option=])\n案例： 鼠标在盒子上移动，鼠标停止500ms之后，里面的数字+1\nconst box = document.querySelector(\u0026#39;.box\u0026#39;) let i = 1 function mouseMove(){ box.innerHTML = i++ } // box.addEventListener(\u0026#39;mousemove\u0026#39;,mouseMove) // 利用lodash库实现防抖 500ms之后采取+1 // 语法： _.debounce(fun,时间) box.addEventListener(\u0026#39;mousemove\u0026#39;,_.debounce(mouseMove, 500)) 2. 手写防抖函数 核心思路： 防抖核心就是利用定时器 (setTimeout) 来实现\n声明一个定时器变量 当鼠标每次滑动都先判断是否有定时器，如果有定时器先清楚以前的定时器 如果没有定时器则开启定时器，记得存在变量里 在定时器里面调用执行的函数 // 创建一个函数 第一个参数时方法，第二个是时间 function mouseMove(){ box.innerHTML = i++ } function debounce(fn, t){ let timer return function(){ // 如果有删除掉 if（timer）clearTimeout(timer) timer = setTimeout(function(){ fn() },t) } } box.addEventListener(\u0026#39;mousemove\u0026#39;,debounce(mouseMove, 500)) 5. 节流 （throttle） 单位时间内，频繁触发事件，只能执行一次。王者荣耀的技能冷却，期间无法继续释放技能\n节流适用于__高频事件: __像是鼠标移动mousemove， 页面尺寸缩放resize, 滚动条滚动scroll 等等\n1. lodash 提供节流函数 ​\t_.throttle(function, 时间)\n案例\nconst box = document.querySelector(\u0026#39;box\u0026#39;) let i = 1 function mouseMove(){ box.innerHTML = i++ // 如果里面存在大量消耗性能的代码，如dom操作、数据处理，可能会造成卡顿 // 利用Lodash库实现节流， 500ms之后采取+1 box.addEventListener(\u0026#39;mousemove\u0026#39;,_.throttle(mouseMove, 500)) } 2. 手写节流函数 核心思路： 防抖核心就是利用定时器 (setTimeout) 来实现\n声明一个定时器变量 当鼠标每次滑动都先判断是否有定时器，如果有定时器先清楚以前的定时器 如果没有定时器则开启定时器，记得存在变量里 在定时器里面调用执行的函数 在定时器里面把定时器清空 const box = document.querySelector(\u0026#39;box\u0026#39;) let i = 1 function mouseMove(){ box.innerHTML = i++ // 如果里面存在大量消耗性能的代码，如dom操作、数据处理，可能会造成卡顿 // 利用Lodash库实现节流， 500ms之后采取+1 } function throttle(fn, t){ let timer = null return function(){ if(!timer){ timer = setTimeout(function(){ fn() // 清空定时器 // 为什么不用clearTimeout？ // 因为不能在开启的定时器里，删除定时器 timer = null },t) } } } box.addEventListener(\u0026#39;mousemove\u0026#39;,throttle(mouseMove, 500)) } 防抖和节流总结 性能优化 说明 使用场景 王者荣耀类比 防抖 单位时间内，频繁触发事件，只执行最后一次 搜索框搜索输入、手机号、邮箱验证输入检测 回城 节流 单位时间内，频繁触发事件，只执行一次 高频事件：鼠标移动mousemove、页面尺寸缩放 resize、滚动条滚动scroll 技能冷却 补充视频相关事件 事件名称 事件描述 ontimeupdate 在视频/音频(audio/video)当前的播放位置发送改变时触发 onloadeddata 事件当前帧的数据加载完成且还没有足够的数据播放视频/音频(audio/video)的下一帧时触发 ","permalink":"https://jingyiwu-codespace.github.io/zh/posts/tech/javascript_advanced/","summary":"JavaScript 进阶篇!! 学习完看框架啦!!","title":"学习: JavaScript 进阶篇"},{"content":"Day1 变量声明 var、 let 、const\n在使用中应该优先使用const\nconst 语义化更好 很多变量在声明时表示标量不会更改 实际开发中，react框架，基本const 如果事后发现需要被更改，再改为let 案例:\n以下案例可不可以把let改外const ?\nlet name = \u0026#39;刘德华\u0026#39; let song = \u0026#39;忘情水\u0026#39; document.write(name + song) //可以，因为值没有被改变 let num1 = +prompt(\u0026#39;请输入第一个数值: \u0026#39;) let num2 = +prompt(\u0026#39;请输入第二个数值: \u0026#39;) alert(`两者相加的结果是：${num1} + ${num2} `) //可以，因为值没有被改变 let num = 1 num = num + 1 //不可以，值被改变了 //如下同理 for (let i = 0;i \u0026lt; nums.length; i++){ document.write(nums[i]) } //i的值一直被改变 let arr = [\u0026#39;red\u0026#39;,\u0026#39;green\u0026#39;] arr.push(\u0026#39;pink\u0026#39;) // 可以，因为arr的地址没有变，只是内容发生了变化 let person = { uname: \u0026#39;pink老师\u0026#39;, age: 18, gender:\u0026#39;女\u0026#39; } person.address = \u0026#39;武汉黑马\u0026#39; // 也可以 ，同理地址没变，只是内容发生了变化 const 声明的值不能更改，而且const声明变量的时候需要提前初始化 但对于引用数据类型, const声明变量，里面存的不是值，而是地址 const names = [] names = [1, 2, 3] // 不可以！！！，因为 [1,2,3]意味着是新的数组，新的地址 const obj = {} obj = { uname: \u0026#39;pink老师\u0026#39; } // 不可以！！ obj 已经是{},不能再次新建{} // obj.name = \u0026#39;pink老师\u0026#39; 可以通过这种形式 为什么const声明的对象可以修改里面的属性？\n因为对象是引用类型，里面存储的是地址，只要地址不变，就不会报错 建议数组和对象使用const来声明 什么时候使用let声明变量？\n如果基本数据类型的值或者引用类型的地址发生变化的时候 比如 一个变量进行加减运算，比如for循环中的i++ 作用及分类 使用 JS 去操作 html 和 浏览器\nDAM(文档对象模型)\nBOM(浏览器对象模型)\nDOM ( Document Object Model ) 用来呈现以及任意 html 或 xml 文档交互的API\nDOM 是浏览器提供的一套专门操作网页内容的功能\n开发网页内容特效和实现用户交互 DOM树 将HTML文档以树状结构直观的表现出来，称为DOM树 描述网页内容关系的名词 作用： DOM树直观的体现了标签之间的关系 DOM 对象 浏览器根据 html 标签生成 JS对象\n所有的标签属性都能在这个对象上面找到 修改这个对象的属性会自动映射到标签身上 DOM 的核心思想 将网页当作对象处理 const div = document.querySelector(\u0026#39;div\u0026#39;) // typeof div 为dom对象 object document 对象 是 DOM 里提供的一个对象, DOM里面最大的对象\n所以他提供的属性和方法都是用来访问和操作网页内容的\ndocument.write ( )\n网页的所有内容都在document里面\n获取 DOM 元素 根据 CSS 选择器来获取 DOM 元素 （重点）\n语法 1. 选择匹配一个元素 // 获取匹配的第一个元素 document.querySelector(\u0026#39;css选择器\u0026#39;) // example // 用标签获取 const box1 = document.querySelector(\u0026#39;tag\u0026#39;) // 用class获取 const box2 = document.querySelector (\u0026#39;.class\u0026#39;) // 用id获取 const box3 = document.querySelector (\u0026#39;#id\u0026#39;) // 嵌套标签 const box4 = document.querySelector (\u0026#39;ul li\u0026#39;) const box4 = document.querySelector (\u0026#39;ul li:first-child\u0026#39;) 2. 选择匹配多个元素 document.querySelecorAll (\u0026#39;css选择器\u0026#39;) 参数 包含一个或多个有效的 css 选择器 字符串 返回值 document.querySelector()\nCSS 选择器匹配的第一个元素 (HTMLElement 对象)\ndocument.querySelectorAll('ul li')\nCSS 选择器匹配的 NodeList 对象集合\n!! NodeList 是伪数组\n有长度、有索引 但没有pop(), push()等数组方法 想要得到里面的每个对象，需要遍历(for)的方式获得，注意数组的遍历用for，对象的遍历用 for in\n总结 获取一个DOM元素使用querySelector(), 可以直接修改 获取多个DOM元素使用querySelectorAll( ), 通过遍历的方式修改 其他获取DOM元素方法 (了解)\ndocument.getElementById(\u0026#39;nav\u0026#39;) document.getElementsByTagName(\u0026#39;div\u0026#39;) document.getElementsByClassName(\u0026#39;w\u0026#39;) 操作元素内容 能够修改元素的文本，更换内容\nDOM 对象都是根据标签生成，所以操作标签，本质上是操作DOM对象\n操作对象使用 的点语法\n如果想要修改标签元素里面的内容，则可以使用如下几种方式：\nobj.innerText-\u0026gt; 属性\nobj.innerHTML-\u0026gt; 属性\n元素innerText属性 将文本内容添加/更新到任意标签位置 显示纯文本，不解析标签 元素innerHTML属性 与上方innerText大致相同，但是解析html标签 \u0026lt;body\u0026gt; \u0026lt;div class = \u0026#34;box\u0026#34;\u0026gt; 我是文字内容 \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; const box = document.querySelector(\u0026#39;.box\u0026#39;) console.log(box.innerText) //获取文字内容 box.innerText = \u0026#39;我是一个盒子\u0026#39; //修改文字内容 box.innerText = \u0026#39;\u0026lt;strong\u0026gt; 我是一个盒子 \u0026lt;/strong\u0026gt;\u0026#39; // strong 会按照文本形式输出，不会解析为加粗 //innerHTML console.log(box.innerHTML) //获取内容 box.innerHTML = \u0026#39;\u0026lt;strong\u0026gt; 我是一个盒子 \u0026lt;/strong\u0026gt;\u0026#39; //会变粗，解析html标签 \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 操作元素属性 操作元素常用属性 通过 JS 设置/修改标签元素属性，比如通过src更换图片\n常见属性：href、title、src\n语法: obj.attribute = value\n//1. 获取元素 const pic = document.querySelector(\u0026#39;img\u0026#39;) //2. 操作元素 pic.src = \u0026#39;/images/b-2.ipg\u0026#39; pic.title = \u0026#39;刘德华黑马演唱会\u0026#39; //3. body不需要获取，直接选择 document.body = \u0026#39;....\u0026#39; 操作元素样式属性 还可以通过 JS 设置/修改标签元素的样式属性\n轮播图小圆点自动更换样式颜色\n点击按钮可以滚动图片，移动图片位置等等\nstyle属性操作CSS 语法\nobj.style.attribute = value\nCSS 样式 \u0026lt;style\u0026gt; div{ width: 200px; height: 200px; background-color: pink; } \u0026lt;/style\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class = \u0026#39;box\u0026#39;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 1. 获取元素 const box = document.querySelector(\u0026#39;.box\u0026#39;)、 // 2. 修改样式 对象.style.样式属性 = \u0026#39;值\u0026#39; 记得+单位 // style 关键词是固定不变的！！！ box.style.width = \u0026#39;300px\u0026#39; // css多组单词， background-color 转换成小驼峰命名法 box.style.backgroundColor = \u0026#39;hotpink\u0026#39; box.style.border = \u0026#39;2px solid blue\u0026#39; box.style.borderTop = \u0026#39;2px solid red\u0026#39; \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 总结\n设置/修改元素样式属性通过 style属性引出来\n如果修改div盒子的样式，比如padding-left，如何写？\nElement.style.paddingLeft = \u0026lsquo;300px\u0026rsquo; 小驼峰命名法\n因为我们是样式属性，大部分数字方面需要➕单位px\n类名className操作CSS 如果修改的样式比较多，直接通过style属性修改比较繁琐，我们可以通过借助css类名的形式\n语法\n元素.className = \u0026#39;css里面的类名\u0026#39; 由于class是保留词、关键字，所以使用className去代替\nclassName是使用新值换旧值\n\u0026lt;head\u0026gt; \u0026lt;style\u0026gt; div { width: 200px; height:200px; background-color: pink; } .nav{ color: red } .box{ width: 300px; height: 300px; background-color: skyblue; margin: 100px auto; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class = \u0026#39;nav\u0026#39;\u0026gt; 123 \u0026lt;/div\u0026gt; // nav class会被 js 覆盖掉,换成box，样式也会被替换 \u0026lt;script\u0026gt; const div = document.querySelector(\u0026#39;div\u0026#39;) // 把div的class设置为box，这样可以更换样式 div.className = \u0026#39;box\u0026#39; //如果我两个类名的样式都想保留 div.className = \u0026#39;nav box\u0026#39; \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 常用!! classList -\u0026gt; 操作类控制CSS 为了解决className容易覆盖以前的类名，通过classList方式追加和删除类名 语法 // 追加一个类 元素.classList.add(\u0026#39;类名\u0026#39;) // 删除一个类 元素.classList.remove(\u0026#39;类名\u0026#39;) //切换一个类 元素.classList.toggle(\u0026#39;类名\u0026#39;) 案例 \u0026lt;head\u0026gt; \u0026lt;style\u0026gt; .box { width: 200px; height: 200px; color: #333 } .active { color: red; background } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class = \u0026#39;box \u0026#39;\u0026gt; 文字 \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 通过classList添加 // 1. 获取元素 const box = document.querySlector(\u0026#39;.box\u0026#39;) // 2.1 修改样式-\u0026gt;追加 box.classList.add(\u0026#39;active\u0026#39;) // 2.2 修改样式-\u0026gt;移除 box.classList.remove(\u0026#39;box\u0026#39;) // 2.3 修改样式-\u0026gt;切换 // 先查看此类有还是没有，有就删掉，没有就添加,像是开关 box.classList.toggle(\u0026#39;active\u0026#39;) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 总结：使用className 和 classList区别\n修改样式方便 classList 是追加、删除不影响之前的类名 操作表单元素属性 用value提取内容，不能是使用innerHTML 用type切换文本和密码的展现形式 \u0026lt;body\u0026gt; \u0026lt;input type = \u0026#34;text\u0026#34; value = \u0026#34;电脑\u0026#34;\u0026gt; \u0026lt;script\u0026gt; const uname = document.querySelector(\u0026#39;input\u0026#39;) uname.value //电脑 uname.value //设置表单value值 // 设置密码形式 uname.type = \u0026#39;password\u0026#39; \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 表单属性中添加就有效果，移除没有效果，使用布尔值来表示 true -\u0026gt; 添加钙属性，false -\u0026gt; 移除该属性 disable /checked/ selected \u0026lt;input type = \u0026#34;checkbox\u0026#34; name = \u0026#39;\u0026#39; id = \u0026#34;\u0026#34; checked\u0026gt; //属性与值相同，可省略 \u0026lt;script\u0026gt; // 获取 const ipt = document.querySelector(\u0026#39;input\u0026#39;) console.ipt(ipt.checked) //true // 修改check的状态 ipt.checked = true //更改为勾选状态，布尔值不加“” \u0026lt;/script\u0026gt; 自定义属性 标准属性： 自带的属性 class、 id、 title等等，可以直接使用 点语法操作\ndisabled checked selected\n自定义属性：\nHTML 5 退出来专门data的自定义属性\n标签上一律以data-开头\n在DOM对象上一律以dataset对象方式获取\n\u0026lt;body\u0026gt; \u0026lt;div class = \u0026#34;box\u0026#34; data-id = \u0026#34;10\u0026#34;\u0026gt;盒子\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; const box = documet.querySelector(\u0026#39;.box\u0026#39;) console.log(box.dataset.id) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 间歇函数-定时器 定时器函数可以开启和关闭定时器\n开启定时器\n定时器的返回值是，定时器独有的 ID 号\nsetInterval(函数/函数名，间隔时间) // 间歇函数一旦开启，永不停歇 // 案例 // 使用匿名函数 setInterval (function(){console.log(\u0026#39;一秒执行一次\u0026#39;)},1000) // 使用指定函数 function fn(){ console.log(\u0026#39;一秒执行一次\u0026#39;) } setInterval (fn, 1000) // 因为fn()表示立即调用函数，不符合每隔一秒钟调用 // 定时器又开有关，在内存中可能会用变化，使用let声明 let n = setInterval (fn, 1000) console,log(n) // id = 2 关闭定时器 作用： 每隔一段时间调用这个函数 间隔单位是毫秒 let 变量名 = setInterval(函数，间隔时间) clearInterval(变量名) //一般不会刚创建就停止，而是满足了一定条件再停止 //案例 let timer = setInterval(function(){ console.log(\u0026#39;hi!!!~~~\u0026#39;), 1000 }) clearInterval(timer) Day2 能够给DOM元素添加事件监听​\n什么是事件？\n事件是编程时系统内发生的动作或者发生的事情\n比如用户在网页上单击一个按钮\n什么是事件监听？\n让程序检测是否有事件产生，一旦有时间触发，立即调用一个函数做出响应，称为绑定事件或者注册事件。比如鼠标经过显示下拉菜单，如果点击可以播放轮播图等等\n事件监听 语法 元素对象.addEventListener('事件类型'，要执行的函数)\n三要素 事件源：被事件触发的dom元素 事件类型： 用什么方式触发，比如鼠标单击 click, 鼠标经过mouseover 等等 事件调用函数： 要做什么事 \u0026lt;button\u0026gt; \u0026lt;script\u0026gt; const btn = document.querySelector(\u0026#39;.btn\u0026#39;) //修改元素样式 //注意事件类型必须是字符串形式 //此函数是，点击之后再去执行，每次点击都会执行一次 btn.addEventListener(\u0026#39;click\u0026#39;,function(){ alert(\u0026#39;点击了～～\u0026#39;) }) \u0026lt;/script\u0026gt; \u0026lt;/button\u0026gt; 事件类型 鼠标事件 焦点事件 键盘事件 文本事件 鼠标触发 表单获得光标 键盘触发 表单输入触发 click 鼠标点击 focus 获得焦点 keydown 键盘按下 input用户输入事件 mouseenter 鼠标经过 blur 失去焦点 keyup 键盘抬起触发 mouseleave 鼠标离开 事件对象 ​\t事件对象是什么？\n有事件触发时的相关信息\n例如： 鼠标点击事件中，事件对象存储了鼠标点的位置信息等等\n使用场景\n可以判断用户按下拿个键，比如按下回车键可以发布新闻\n可以判断鼠标点击了哪个元素，从而做相应的操作\n语法 在事件绑定的回调函数的第一个参数就是事件对象\n一般命名为 event ev e\n部分常用属性\n补充 str.trim() -\u0026gt;去除字符串两侧空格\n属性 描述 type 获取当前的事件类型 clientX / clientY 获取光标相对于浏览器可见窗口左上角的位置 offsetX / offsetY 获取光标相对于当前DOM元素左上角的位置 key 用户按下的键盘的值 元素.addEventListener(\u0026#39;click\u0026#39;, function(e)){} // e就是事件对象 // 案例 const input = document.querySelector(\u0026#39;input\u0026#39;) input.addEventListener(\u0026#39;keyup\u0026#39;,function(e){ if (e.key === \u0026#39;Enter\u0026#39;){ console.log(\u0026#39;我按下了回撤键盘\u0026#39;) } }) 环境对象 能够分析判断函数运行在不同环境中 this 所指代的对象\n定义：指的是函数内部特殊的变量this，代表着当前函数运行时所处的环境。\n简单一点，this 指的是函数的调用者 直接调用函数，相当于window.函数，所以this指代window const btn = document.querySelector(\u0026#39;button\u0026#39;) btn.addEventListener(\u0026#39;click\u0026#39;, function(){ //先前的写法 btn.style.color = \u0026#39;red\u0026#39; //this 版本 this.style.color = \u0026#39;red\u0026#39; }) 回调函数 被当作参数的函数，此函数就叫 call function 回调函数\n如果将函数A作为参数传递给函数B，我们称函数A 为回调函数\nfunction fn(){ console.log(\u0026#39;我是回调函数!!\u0026#39;) } //fn 传递给了setInterval，fn就是回调函数 setInterval(fn,1000) //事件点击的本身也是回调函数 box.addEventListener(\u0026#39;click\u0026#39;, function(){ console.log(\u0026#39;也是回调函数!!\u0026#39;) }) 总结\n将函数当作另一个函数的参数传递，此函数叫回调函数 回调函数本质还是函数，只不过把它当成参数 使用匿名函数作为回调函数比较常见 ​\nDay3 事件流 事件流指的是事件完整执行过程中的流动路径\n![image-20240302131910970](/Users/jingyiwu/Library/Application Support/typora-user-images/image-20240302131910970.png)\n事件捕获 从大到小 例子： 中国-\u0026gt;浙江-\u0026gt;杭州\n若给盒子都注册同名事件，在执行时，从DOM的根元素开始去执行对应的事件（从外到里）\n事件捕获需要写对应代码才能看到效果\n语法\nDOM.addEventListener(事件类型，事件处理函数，是否使用捕获机制)\naddEventListener 第三个参数传入 true代表捕获阶段触发（很少使用）\n默认为false, 代表冒泡阶段\n若使用L0事件监听, onclick，只有冒泡没有捕获\n事件冒泡 从小到大 例子： 杭州-\u0026gt;浙江-\u0026gt;中国\n当一个元素的事件被触发时，同样的事件将会在该元素的所有祖先元素中一次出发，这一过程被称为事件冒泡 当一个元素触发事件后，会依次向上调用所有父级元素的同名事件 阻止冒泡 因为默认出现冒泡模式，导致事件影响到父级元素\n若想把事件限制在当前元素内，需要组织事件冒泡\n先拿到事件对象\n语法 事件对象.stopPropagation() //e为事件对象 //此方法可以组织事件流动传播，对冒泡/捕获都有效 //案例 son.addEventListener(\u0026#39;click\u0026#39;,function(e){ alert(\u0026#39;我是儿子\u0026#39;) e.stopPropagation() } 解绑事件 1. on事件方式 ​ 直接使用null覆盖后就可以实现事件的解绑\n//L0 绑定事件 btn.onclick = function(){ alert(\u0026#39;点击了\u0026#39;) } btn.onclick = null 2. L2事件方式 必须使用removeEventListerner (事件类型，事件函数，[获取捕获或冒泡阶段] ) 匿名函数无法解绑 !! function fn(){ alert(\u0026#39;点击了\u0026#39;) } //绑定事件 btn.addEventListener(\u0026#39;click\u0026#39;,fn) //解绑事件 btn.removeEventListener(\u0026#39;click\u0026#39;,fn) 两种注册事件区别 传统 on 注册(L0) 事件监听注册(L2) 同一对象覆盖之前的同一注册事件 会 不会 解绑事件方式 obj.onclick = null obj.remove(\u0026lsquo;click\u0026rsquo;, fn) 匿名函数无法被解绑 可选冒泡/捕获 只冒泡 可冒泡可捕获 事件委托 事件委托利用事件流的特征解决一些开发需求的知识技巧 (事件冒泡)\n优点： 减少注册次数，提高程序性能\n原理：利用事件冒泡的特点\n给父元素注册事件，当触发子元素时，会冒泡到父元素身上，从而触发父元素的事件\n实现：事件对象.target.tagName 可以获得真正的触发事件元素\n\u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;第1个\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;第2个\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;第3个\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;第4个\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;第5个\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; // 无事件委派 const lis = document.querySelector(\u0026#39;ul li\u0026#39;) for (let i = 0;i \u0026lt; lis.length; i++){ lis[i].addEventListener(\u0026#39;click\u0026#39;,function(){ alert(\u0026#39;我被点击了\u0026#39;) }) } // 事件委派 // 父元素添加点击事件 // 目前li子元素没有点击事件，但会冒泡至 ul 元素的点击事件 const parent = document.querySelector(\u0026#39;ul\u0026#39;) parent.addEventListener(\u0026#39;click\u0026#39;, function (e) { console.log(e.target) // 我们点击的对象 console.dir(e.target) //打印对象 if (e.target.tagName == \u0026#39;LI\u0026#39;) { e.target.style.color = \u0026#39;red\u0026#39;; } }) 阻止默认行为发生 事件对象.preventDefalut\n\u0026lt;a href = \u0026#34;http://www.baidu.com\u0026#34;\u0026gt;百度一下\u0026lt;/a\u0026gt; ## 正常链接会跳转，现在阻止他不让跳转 \u0026lt;script\u0026gt; const form = document.querySelector(\u0026#39;form\u0026#39;) form.addEventListerner(\u0026#39;submit\u0026#39;,function(e){ e.preventDefalut() }) ## 现在不会跳转了 \u0026lt;/script\u0026gt; 其他事件 页面加载事件 记载外部资源 (如图片、外联 css 和 javascript 等) 加载完毕时触发的事件\n需要场景：\n有些时候需要等页面资源全部处理完，再做一些事情 老代码喜欢把script 写在head中，这时候直接找dom元素找不到 事件名： load\n监听页面所有资源加载完毕，就执行回调函数 给window添加load事件\nwindow.addEventListener(\u0026#39;load\u0026#39;, function(){ //执行操作，等页面所有资源加载完毕，执行回调函数 //避免了dom元素找不到的情况 const btn = document.querySelector(\u0026#39;button\u0026#39;) btn.addEventListener(\u0026#39;click\u0026#39;,function(){ alert(11) }) }) 监听单个元素 注意： 不光可以监听整个页面资源加载完毕，也可针对某个资源绑定load事件\nimg.addEventListener(\u0026#39;load\u0026#39;,function(){ //等待图片加载完毕，再去执行里面的代码 }) 监听HTML 加载事件 当初始的HTML 文档被完全加载和解析完成之后, DOMContentLoaded事件被触发，无需等待样式表，图像等完全加载\n事件名：DOMComtentLoaded\n此时监听页面不是window 而是document!!\ndocument.addEventListener(\u0026#39;DOMContentLoaded\u0026#39;,function(){ //执行操作 }) 元素滚动事件 滚动条在滚动时持续触发的事件\n使用场景： 很多网页需要检测用户把页面滚动在某一个区域后做一些处理，比如固定导航栏，比如返回顶部。⚠️有滚动条才行!!\n事件名：scroll 监听整个页面滚动（使用最多）\n补充，如果想获取html对象，使用document.documentElement\n监听dom\nwindow.addEventListener(\u0026#39;scroll\u0026#39;,function(){ //执行操作 console.log(document.documentElement.scrollTop) const n = document.documentElement.scrollTop // n为数字型，不带单位 if (n\u0026gt;=100){ div.style.display = \u0026#39;block\u0026#39; }else { div.style.display = \u0026#39;none\u0026#39; } }) document.addaddEventListener(\u0026#39;scroll\u0026#39;,function(){ //执行操作 }) ​\t页面滚动事件 —获取位置\nscrollLeft 和 scrollTop（属性）\n获取被卷的大小\n获取元素内容向左，向上滚出去看不到的距离\n这两个值可读写\n![image-20240302235856319](/Users/jingyiwu/Library/Application Support/typora-user-images/image-20240302235856319.png)\nscrollTo() 方法把内容滚动到指定坐标 // 让页面滚动到指定坐标 windows.scrollTo(x,y) 页面尺寸事件 会在窗口尺寸改变时触发事件 // resize 浏览器窗口大小发生变化的时候触发事件 windows.addEventListener(\u0026#39;resize\u0026#39;,function(){ //z执行代码 }) 检测屏幕宽高\n获取元素的可见部分宽高 (不包含边框, margin, 滚动条等)\n// clientWidth clientHeight window.addEventListener(\u0026#39;resize\u0026#39;,function(){ let w = document.documentElement.clientWidth }) 元素尺寸与位置 获取宽高\n获取宽高 获取元素的自身宽高、包含元素自身设置的宽高、padding、border offsetwidth offsetHeight 获取出来是数值， 方便计算 注意：获取的是可视宽高，如果盒子是隐藏的 (display: none), 获取结果是 0. 获取位置 获取元素距离自己最近带有定位属性的父级元素的左、上距离\noffsetLeft offsetTop 是 只读属性\nelement.getBoundingClientRect()是方法\n返回元素的大小及其相对于视口的位置\n总结\noffsetWidth 和 offsetHeight 得到元素的什么宽高？\n内容 + padding + border\noffsetTop 和 offsetLeft 得到的位置以谁为准？\n带有定位的父级\n如果都没有，则以文档左上角为准\n属性 作用 说明 scrollLeft / scrollTop 被卷去的头部和左侧 配合页面滚动来使用，可读写 clientWidth / clientHeight 获得元素宽度和高度 不包含border, margin, 滚动条。用于js获取元素大小，只读属性 offsetWidth / offsetHeight 获得元素宽度和高度 包含border、padding、滚动条等等，只读属性 offsetLeft / offsetTop 获取元素距离自己定位父级元素左、上距离 获取元素位置时使用，只读属性 Day4 日期对象 掌握日期对象，让网页显示日期\n可以得到当前的系统时间\n对象实例化 在代码中new关键字时，将此操作称为实例化\n创建一个事件对象并获取时间\n获得当前时间： const date = new Date()\n获得指定时间：const date = new Date('2022-5-1 08:30:00')\n可以在倒计时中使用\n日期对象方法 在开发中，日期对象返回的数据不能直接使用，需要转化成实际开发中的常用格式\n方法 作用 说明 getFullYear( ) 获得年份 获取四位年份 getMonth( ) 获得月份 取值 0-11 getDate( ) 获取月份中的每一天 不同月份取值不同 getDay( ) 获取星期 取值 0-6 getHours( ) 获取小时 取值 0-23 getMinutes( ) 获取分钟 取值 0-59 getSecond( ) 获取秒 取值 0-59 \u0026lt;script\u0026gt; const div = document.querySelector(\u0026#39;div\u0026#39;) function getMyDate(){ const date = new Date() let h = date.getHours() let m = date.getMinutes() let s = date.getSecond() h = h \u0026lt; 10 ? \u0026#39;0\u0026#39; + h : h m = m \u0026lt; 10 ? \u0026#39;0\u0026#39; + m : m h = s \u0026lt; 10 ? \u0026#39;0\u0026#39; + s : s return `${date.getFullYear()}Year ${date.getMonth()+1()}Month${date.getDate()}Day ${h}:${m}:${s}`} div.innerHTML = getMyDate // 让时间动起来 setInterval (function(){ div.innerHTML = getMyDate },1000) \u0026lt;/script\u0026gt; 其他简便形式\n\u0026lt;script\u0026gt; const div = document.querySelector(\u0026#39;div\u0026#39;) const date = new Date() //对象方法 div.innerHTML = date.toLocalString() //2022/4/1 09:41:21 div.innerHTML = date.toLocalDateString() // 2022/4/1 div.innerHTML = date.toLocalTimeString() //09:41:21 setInterval (function(){ div.innerHTML = date.toLocalString() },1000) \u0026lt;/script\u0026gt; 时间戳 什么是时间戳：\n从1970年1月1日起至现在的毫秒数，是一种特殊的计量时间的方式，使用场景倒计时\n算法：\n将来的时间戳 - 现在的时间戳 = 剩余时间毫秒数\n剩余时间毫秒数 转换为 剩余时间的 年 月 日 时 分 秒 就是倒计时时间\n举例：\n2000ms - 现在时间戳 1000ms = 1000ms\n转换后-\u0026gt; 0小时 0分 1秒\n当前的时间戳 + new Date()\n转换公式：\nd = parseInt (总秒数/ 60/ 60/ 24) //计算天数\nh = parseInt (总秒数/ 60/ 60 % 24) //计算小时\nm = parseInt (总秒数 /60 % 60) //计算分钟\ns = parseInt (总秒数%60) //计算当前秒数\n获取时间戳的方法 使用 getTime()\n必须实例化\nconst date = new Date() console.log(date.getTime()) const date = new Date(\u0026#39;2022-4-1 18:30\u0026#39;) 简写 + new Date()\n使用Date.now( )\n但是只能得到当前的时间戳，前面两种可以返回指定时间的时间戳\nconst arr = [\u0026#39;星期天\u0026#39;,\u0026#39;星期一\u0026#39;,\u0026#39;星期二\u0026#39;,\u0026#39;星期三\u0026#39;,\u0026#39;星期四\u0026#39;,\u0026#39;星期五\u0026#39;,\u0026#39;星期六\u0026#39;] console.log(arr[new Date().getDay()]) 总结 实例化日期对象怎么写？ new Date( )\n日期对象方法里面月份和星期有什么注意的?\n月份 0-11 （得+1）， 星期 0-6 (不用+1，0是周日)\n获取时间戳有哪三种方式？\ndate.getTime() +new Date() Date.now() 重点记住 +new date() 既可以返回当前时间戳，也可以返回指定时间戳 节点操作 DOM节点 DOM 树里面的每一个内容都称为节点\n节点类型 1. 元素节点-\u0026gt; 所有的标签 body, div；html 是跟节点 2. 属性节点-\u0026gt; 所有的属性，比如href / class属性 3. 文本节点-\u0026gt; 所有的文本 4. 其他节点 查找节点 基于关系的查找，返回内容还是对象\n父节点查找 parentNode属性\n返回最近一级的父节点，找不到返回为null. (亲爸爸)\n子元素.parentNode\n\u0026lt;body\u0026gt; \u0026lt;div class = \u0026#34;dad\u0026#34;\u0026gt; \u0026lt;div class = \u0026#34;baby\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; const baby = document.querSelector(\u0026#39;.body\u0026#39;) console.log(baby) // 返回dom对象 console.log(baby.parentNode) // 返回dom对象 \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 子节点查找 childNodes\n获得所有子节点，包括文本节点 (空格、换行)、注释节点等\nchildren 属性 (重点)\n仅获得所有元素节点\n返回的还是伪数组, 和.querySelectorAll等价\n父元素.children\n\u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;script\u0026gt; const ul = document.querySelector(\u0026#39;ul\u0026#39;) console.log(ul.children) //得到所有子节点，伪数组 【亲儿子】 \u0026lt;/script\u0026gt; 兄弟关系查找 下一个兄弟节点 nextElementSibling 上一个兄弟节点 previousElementSibling 增加节点 需要在页面中增加元素\n创建新的节点放入指定的元素内部\n1. 创建节点 创造出一个新的网页元素，在添加到网页，一般先创建节点，再插入节点\n创建元素节点的方法 // 创造一个新的元素节点 document.createElement(\u0026#39;标签名\u0026#39;) 追加节点 要想在界面看到，还得插入到某个父元素中\n插入到父元素的最后一个子元素, 甚至会放到标签后面 // 插入到父元素的最后 父元素.appendChild(要插入的元素) document.createElement(\u0026#39;标签名\u0026#39;) const div = document.createElement(\u0026#39;div\u0026#39;) document.body.appendChild(div) 插入到父元素中某个子元素前面 父元素.insertBefore(要插入的元素，在哪个元素前面) // 案例 const ul = document.querySelector(\u0026#39;ul\u0026#39;) const li = document.queryElement(\u0026#39;li\u0026#39;) li.innerHTML = \u0026#39;我是li\u0026#39; ul.appendChild(li) // 添加li为ul的最后与阿苏 ul.insertBefore(li, ul.children[0]) // 插入到列表第一个元素之前 // 2. 克隆节点 // 克隆一个已有的元素节点 元素.cloneNode(布尔值) cloneNode会克隆出一个跟原标签一样的元素，括号内传入布尔值\n若为true，则代表克隆时会包含后代节点一起克隆 若为false，则代表克隆时不包括后代节点 默认为false \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;1\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;2\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;3\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;script\u0026gt; const ul = document.querySelector(\u0026#39;ul\u0026#39;) // 1. 克隆节点 元素.cloneNode(true),深克隆 const li1 = ul.children[0].cloneNode(true) ul.appendChild(ul.children[0].cloneNode(true)) //\u0026lt;li\u0026gt;1\u0026lt;/li\u0026gt; //\u0026lt;li\u0026gt;2\u0026lt;/li\u0026gt; //\u0026lt;li\u0026gt;3\u0026lt;/li\u0026gt; //\u0026lt;li\u0026gt;1\u0026lt;/li\u0026gt; // 2. 克隆节点 浅克隆， 没有值，只有标签 //\u0026lt;li\u0026gt;1\u0026lt;/li\u0026gt; //\u0026lt;li\u0026gt;2\u0026lt;/li\u0026gt; //\u0026lt;li\u0026gt;3\u0026lt;/li\u0026gt; //\u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/script\u0026gt; 删除节点 JavaScript 原生DOM操作中，要删除元素必须通过父元素删除\n父元素.removeChild(要删除的元素) // 案例 \u0026lt;script\u0026gt; const ul = document.querySelector(\u0026#39;ul\u0026#39;) ul.removeChild(ul.children[0]) \u0026lt;/script\u0026gt; 如不存在父子关系，删除不成功 删除节点（节点不存在）和隐藏节点（存在于HTML） M端事件 移动端\n触屏事件 触屏touch事件 说明 touchstart 手指触摸到一个DOM元素是触发 touchmove 手指在一个DOM元素上滑动时触发 touchend 手指从一个DOM元素上 移开时触发 Swiper插件 Day 5 1. BOM Browser Object Model\nWindow 对象是一个全局对象，也可以说是 JavaScript中的顶级对象\ndocument, alert(), console.log() 这些都是window的属性\n基本BOM的属性和方法都是window的\n所有通过var定义在全局作用域的变量、函数，都会变成window对象的属性和方法\nwindow对象下的属性和方法调用时可以省略window\ndocument.querySelector() window.documet.querySelector() console.log(document === window.document) // true function fn(){ console.log(11) } window.fn() // 和直接调用fn没什么区别 var num = 10 //注意用var定义，而不用let和const console.log(window.num) 定时器-延时函数 setTimeout 仅仅执行一次，可以理解为把一段代码延迟执行，平时省略window\n语法 setTimeout(回调函数，等待的毫秒数) 清楚延时函数 let timer = setTimeout(回调函数， 等待毫秒数) clearTimeout(timer) 延时器需要等待，所以后面的代码会先执行，返回值还是id 每次调用延时器都会产生一个新的延时器 JS 执行机制 JavaScript 的特点就是单线程，同一时间只能做一件事\n单线程意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。导致问题： 如果 JS 执行的时间过长，会造成页面渲染不连贯，导致页面渲染加载阻塞。\n为了解决问题，允许JavaScript 脚本创建多个线程， 于是出现 同步 \u0026amp; 异步，两者本质区别-\u0026gt; 执行任务的顺序不同\n同步： 烧水-\u0026gt; 洗菜-\u0026gt; 做饭\n异步： 烧水的同时洗菜 -\u0026gt; 做饭\n同步任务 同步任务在 主线程 执行，形成一个执行栈 异步任务 JS 的异步是通过回调函数实现\n任务类型\n普通事件 click, resize 资源加载 load, error 定时器 setInterval, setTimeout 异步任务相关添加到任务队列中 (也称消息队列)\n个人理解是，所有需要时间的事件都会放入任务队列\n执行流程 先执行 执行栈中的同步任务 异步任务放入任务队列中 一旦执行栈中的所有同步任务执行完毕，系统会按次序读取任务队列中的异步任务，于是读取的异步任务结束等待状态，进入执行栈，开始执行 由于主线程不断的重复获得任务、执行任务、再获取任务、在执行，所以这种机制被称为 事件循环 (event loop)\nlocation 对象 location 的数据类型是对象， 拆分并保存了URL地址的各个组成部分\n语法\u0026amp;常用属性与方法 console.log(window.location) // 等同于 console.log(location) location.href 可以得到当前文件URL地址 可以通过 js 方式跳转到目标地址 console.log(location.href) // href 赋值跳转页面 location.href = \u0026#39;http://www.itcast.cn\u0026#39; location.search .search 属性获取地址中携带的参数，符号 ? 之后\nconsole.log(location.search) // \u0026#39;?username=pink\u0026amp;pwd=123456\u0026#39; location.hash .hash属性获取地址中哈希值，符号#后面的部分\nconsole.log(location.hash) // \u0026#39;#friend\u0026#39; location.reload() .reload() 方法用来刷新当前页面，传入参数true表示强制刷新\n\u0026lt;button\u0026gt;点击刷新\u0026lt;/button\u0026gt; \u0026lt;script\u0026gt; let btn = document.querySelector(\u0026#39;button\u0026#39;) btn.addEventListener(\u0026#39;click\u0026#39;,function(){ location.reload() // 普通刷新 location.reload(true) // 强制刷新 类似 control + f5 }) \u0026lt;/script\u0026gt; navigator 对象 navigator 的数据类型是对象，该对象下记录了浏览器自身相关的信息\n常用属性 navigator.userAgent\n通过userAgent检测浏览器的版本及平台\n// 检测userAgent(浏览器信息） !(function(){ const userAgent = navigator.userAgent // 验证是否为Android或iPhone const android = userAgent.match((Android);?[¥s¥])) const iphone = userAgent.match((iPhone);?[¥s¥]) if (android ||iphone){ location.href = \u0026#39;http://www.itcast.cn\u0026#39; } })() 补充： 关于立即执行函数的不同写法\n(function(){})(); !function(){}() history 对象 数据类型为对象，主要管理历史记录，该对象与浏览器地址栏的操作相对应， 如前进、后退、历史记录等德\n常用方法 方法 作用 back( ) 后退功能 forward( ) 前进功能 go (参数) 前进后退功能 参数如果是1，则前进1个页面。如果为-1，后退1个页面 2. 本地存储 介绍 数据存储在用户浏览器中 设置、读取方便、页面刷新不丢失数据 容量较大， sessionStorage 和 localStorage 约5M左右 localStorage 可以将数据永久存储在本地（用户的电脑），除非手动删除，否则关闭页面也存在 以键值对的形式存储使用 在检查页面中的 Application -\u0026gt; local Storage内查看 跨域数据不同步 本地存储只能存储字符串类型， 如果是数字也会改成文本 语法 本质是增删改查\n// 存储数据 //key 一定要加‘’，如果不加引号，会被当成变量 localStorage.setItem(key, value) // 获取数据 localStorage.getItem(key) // 删除本地存储 localStorage.removeItem(key) //也可以删除全部【慎用】 clearAll // 改数据 localStorage.setItem(key, newValue) 案例\n\u0026lt;script\u0026gt; // 要存储一个名字 uname localStorage.setItem(\u0026#39;uname\u0026#39;, \u0026#39;Jennie\u0026#39;) // 获取数据 console.log(localStorage.getItem(\u0026#39;uname\u0026#39;)) // 删除数据 localStorage.removeItem(\u0026#39;uname\u0026#39;) // 改数据 localStorage.setItem(\u0026#39;uname\u0026#39;,\u0026#39;Danny\u0026#39;) \u0026lt;/script\u0026gt; sessionStorage 声明周期为关闭浏览器窗口 在同一窗口下的数据可以共享 以键值对的形式存储数据 用法与localStorage相同 存储复杂数据类型 本地只能存储字符串， 无法存储复杂数据类型 (字典或数组)\n将数据抓换成 JSON字符串，再存储在本地。因为本地存储只能存储字符串\n把 JSON字符串转换为对象\nJSON.parse()\nJSON 对象 属性和值有引号，统一是双引号 JSON.stringify(obj) \u0026lt;script\u0026gt; const obj = { uname: \u0026#39;pink老师\u0026#39;, age: 18, gender: \u0026#39;女\u0026#39; } // 存储 复杂数据类型 无法直接使用 // localStorage.setItem(\u0026#39;obj\u0026#39;,obj) // 因为复杂数据类型存储必须转换为 JSON 字符串存储 localStorage.setItem(\u0026#39;obj\u0026#39;,JSON.stringify(obj)) // 再将JSON字符串转换为对象 console.log(typeof localStorage.getItem(\u0026#39;obj\u0026#39;)) const str = localStorage.getItem(\u0026#39;obj\u0026#39;) console.log(JSON.parse(str)) \u0026lt;/script\u0026gt; 3. map( ) \u0026amp; join( ) 字符串拼接新思路 map() 和join()实现字符串拼接\nmap() 可以遍历数组处理数据，并且 返回新的数组 const arr = [\u0026#39;red\u0026#39;, \u0026#39;blue\u0026#39;, \u0026#39;green\u0026#39;] const newArr = arr.map(function(ele, index){ // 拿到数组中的每个元素 console.log(ele) //数组元素 console.log(index) //数组索引号 return ele + \u0026#39;颜色\u0026#39; // [\u0026#39;red\u0026#39;颜色, \u0026#39;blue颜色\u0026#39;, \u0026#39;green颜色\u0026#39;] } map 也称为映射，指两个元素的集之间相互 ‘对应’ 的关系\nmap与forEach的区别，map有返回值，forEach没有\njoin() 方法 将数组转换为字符串\njoin() 无参数表示，字符串用，分隔 join(\u0026rsquo; \u0026lsquo;) 参数里面是空字符串，表示无分隔符号 console.log(newArr.join())\nDay6 正则表达式 Regular Expression\n1. 定义及使用场景 定义 在 JavaScript中，正则表达式也是对象 通常用来查找、替换符合正则表达式的文本 正则表达式是用于匹配字符串中字符组合的模式 使用场景 验证表单：用户名表单只能输入英文字母、数字、下划线，昵称输入框可以输入中文（匹配）\n比如用户名： /^[a-z0-9_-]{3,16}$/\n过滤掉页面中的一些敏感词（替换），或从字符串中获取我们想要的特定部分（提取）等\n2. 语法 JavaScript 定义正则表达式的语法有两种，学习较为简单的方法\n使用步骤：\n定义规则 是否匹配 正则表达式语法：\n/ / 是正则表达式的字面量，只要出现 / /都是正则表达式\n判断是否有符合规则的字符串\ntest()方法 -\u0026gt; 用来查看正则表达式与指定字符串是够匹配\n返回值为布尔值 true or false\nexec() 返回数组\nconst 变量名 = /表达式/ regObj.test( 被检测的字符串 ) regObj.exec( 被检测的字符串 ) const str = \u0026#39;我们在学习前端，希望学习前端能找到好工作\u0026#39; // 正则表达式使用 // 1. 定义规则， 不需要写引号 const reg = /前端/ // 2. 是否匹配 reg.test(str) 3. 元字符 1. 什么是元字符 (特殊字符) ？ 一些具有特殊含义的字符，可以极大提高了灵活性和强大的匹配功能\n比如，英文26个字母 元字符 普通字符 [a-z] abcdefghijklmnopqrstuvwxyz [0-9] 123456789 2. 分类 a. 边界符 表示位置，开头，结尾。必须用什么开头，用什么结尾\n正则表达式中的边界符（位置符）用来提示字符所处的位置，只要有两个字符，并且开启精确匹配模式\n边界符 说明 ^ 表示匹配行首的文本 (以谁开始) $ 表示匹配行尾的文本 (以谁结束) console.log(/哈/.test(\u0026#39;哈\u0026#39;)) //true // 必须以哈开头 console.log(/^哈/.test(\u0026#39;哈\u0026#39;)) //true console.log(/^哈/.test(\u0026#39;二哈\u0026#39;)) //false console.log(/^哈$/.test(\u0026#39;哈\u0026#39;)) //true console.log(/^哈$/.test(\u0026#39;哈哈哈\u0026#39;)) //false 因为没有给量词，处于精确匹配的情况想，数量不对也是false b. 量词 表示重复次数\n量词用来设定某个模式出现的次数\n量词 说明 * 重复0次或者更多次 \u0026gt;= 0 + 重复1次或者更多次 \u0026gt;=1 ? 重复0次或者1次 {n} 重复n次 ==n {n, } 重复n次，或更多次 \u0026gt;=n {n,m} 重复n到m次 \u0026gt;=n and \u0026lt;=m {n,m}中间千万不能有空格!!!\nconsole.log(/^哈$/.test(\u0026#39;哈\u0026#39;)) // true console.log(/^哈*$/.test(\u0026#39;\u0026#39;)) // true 出现\u0026gt;=0 所以返回true console.log(/^哈*$/.test(\u0026#39;哈哈哈\u0026#39;)) // true console.log(/^哈*$/.test(\u0026#39;二哈二\u0026#39;)) // false 因为要以 哈 开头 c. 字符类 比如 \\b 表示 0-9\n匹配字符集合\n里面加上 - 连字符\n使用连字符 - 表示一个范围\nconsole.log(/^[a-z]$/.test('c'))\n[a-z] 表示 a 到 z 26个英文字母都可以 [a-zA-Z] 表示大小写都可以 [0-9] 表示0-9 的数字都可以 里面加上 ^ 取反符号\n[^a-z] 注意!! ^在方括号内部才是取反符号!!!!\n表示匹配除小写字母之外的字符\n.匹配除换行符之外的任何单个字符\n预定义 -\u0026gt; 某些常见模式的简写方式 预定类 说明 \\d 匹配0-9之间的任一数字，相当于[0-9] \\D 匹配所有0-9以外的字符，相当于[^0-9] \\w 匹配任意的字母、数字和下划线，相当于[A-Za-z0-9_] \\W 除所有字母、数字和下划线以外的字符，相当于 [^A-Za-z0-9_] \\s 匹配空格 (包含换行符、制表符、空格符等)，相等于 [\\t\\r\\n\\v\\f] \\S 匹配非空格的字符，相当于[^ \\t\\r\\n\\v\\f] // 只要中括号里面的任意字符出现都返回true console.log(/[abc]/.text(\u0026#39;andy\u0026#39;)) //true console.log(/[abc]/.text(\u0026#39;baby\u0026#39;)) //true console.log(/[abc]/.text(\u0026#39;cry\u0026#39;)) //true console.log(/[abc]/.text(\u0026#39;die\u0026#39;)) //false // 字符类[abc] 只选1个!!!! console.log(/^[abc]$/.text(\u0026#39;a\u0026#39;)) //true console.log(/^[abc]$/.text(\u0026#39;b)) //true console.log(/^[abc]$/.text(\u0026#39;c\u0026#39;)) //true console.log(/^[abc]$/.text(\u0026#39;ab\u0026#39;)) //false // 加量词, 重复2次 console.log(/^[abc]{2}$/.text(\u0026#39;ab\u0026#39;)) //false // 加连字符 console.log(/^[a-z]$/.test(\u0026#39;c\u0026#39;)) // true // 集合版 判定qq号 从10000开始 [0-9]重复4次 ^[1-9][0-9]{4,}$ // 日期格式 ^\\d{4}-\\d{1,2}-\\d{1,2} 总结：\n.表示匹配除换行符之外的任何单个字符 [abc]匹配abc其中的任何单个字符 [a-z]匹配26个小些英文字母其中的任何单个字符 [^a-z]匹配除26个小写字母之外的其他任何单个字符 4. 修饰符 修饰符约束正则执行的某些细节行为，如是否区分大小写，是否支持多行匹配等\n语法 ​\t/表达式/修饰符\ni 是单词 ignore的缩写，正则匹配时字母不区分大小写 g 是单词global的缩写，匹配所有满足正则表达式的结果 console.log(/a/i.test(\u0026#39;a\u0026#39;)) //true console.log(/a/i.text(\u0026#39;A\u0026#39;)) //true console.log(/^java$/.test(\u0026#39;java\u0026#39;)) // true console.log(/^Java$/i.test(\u0026#39;JAVA\u0026#39;)) // true 替换方法 字符串.replace(/正则表达式/,\u0026#39;替换的文本\u0026#39;) // 只替换一个 const str = \u0026#39;java是一门编程语言，学完有工作\u0026#39; str.replace(/java/i,\u0026#39;前端\u0026#39;) // 替换文本内全部，全局替换g const str = \u0026#39;java是一门编程语言，学完有工作\u0026#39; str.replace(/java/gi,\u0026#39;前端\u0026#39;) ","permalink":"https://jingyiwu-codespace.github.io/zh/posts/tech/javascript_webapi/","summary":"JavaScript WebApi!! 程序媛养成之路","title":"学习: JavaScript WebAPIs篇"},{"content":"Day1 JavaScript输入输出 alert(\u0026#39;comment\u0026#39;) //浏览器弹出 prompt(\u0026#39;comment:\u0026#39;) //用户输入 console.log() //写出在控制台 document.write() Varible 变量 let 不允许==多次声明==一个变量， 和python不一样\nlet age = 18 age = 19 let 可以一次声明多个变量:\nlet age = 18, uname = 'Ali'\tArray 数组 数组的声明方式，数组有序\n可以存储任意类型数据\nlet arr1 = [1,2,3,4,5,6] let arr2 = [\u0026#39;Mon\u0026#39;,\u0026#39;Tue\u0026#39;,\u0026#39;Wed\u0026#39;] 数组索引方式\nconsole.log(arr[0]) 数组长度\nconsole.log(arr.length) Const 常量 const PI = 3.14 常量不可以改变，不可以复制，像是Java中的final static的性质。 常量声明的时候必须赋值。 常量命名最好大写。 Data type 数据类型 JavaScript 松散、弱数据类型语言\nJava\nint num = 10; JavaScript: 只有赋值之后才知道类型\nlet num = \u0026#39;二\u0026#39; 基本数据类型： 1. number 可以是整数、小数、正数、负数\n算数运算符： + - * / %\nNaN 数据类型的出现，表示计算错误，或计算机无法理解的结果。黏性属性，任何对NaN的操作返回都是NaN\n2. string + 数字相加，字符相连\nconsole.log(\u0026#34;pink\u0026#34;+\u0026#39;color\u0026#39;+num) 模版字符串\n语法：\n`` (反引号)\n内容拼接变量时，用${}包含变量\nlet age = 18 document.write(`${age}岁`) 3. boolean true false 4. undefined 只声明不赋值，变量默认值undefined 使用场景：开发时声明一个变量，接受数据，如果不确定数据是否传输成功，检测变量是否为undefined 5. null ​\tnull 和 undefined 的区别：\nundefined 表示没有赋值\nnull 表示赋值了，内容为空\nconsole.log(undefined + 1) //Nan console.log(null + 1 ) // 1 使用场景：\nnull作为尚未创建的对象。\n将变量里面存放一个对象，但对象还没创建好，先给null\n检测数据类型 typeof typeof 变量名 typeof (变量名) 引用数据类型 类型转换 1. 隐式转换 +号两边只要有一个字符串，两边都会转成字符串 除了+号以外的算术运算符，都会把数据转成数字类型 +号作为正号解析可以转换为数字型 任何数据和字符串相加结果都是字符串 ![image-20240224102913057](/Users/jingyiwu/Library/Application Support/typora-user-images/image-20240224102913057.png)\n2. 显示转换 Number(data) // 转化数字型 NaN也是number类型，代表非数字 ParseInt(data) // 只保留整数，不会四舍五入 ParseFloat(data) // 可以保留小数 Day 2 运算符 1. 一元运算符 一元运算符 \u0026mdash;\u0026gt; 自增运算、正负号\n前后置自增：\n在独立使用时两者没区别，但是运算时有区别。\n后置i++使用的比较多\nlet num = 10 num +=1 ++ num //前置自增 console.log(++i + 1) //3 // i先自加1，变成2之后，与后面的1相加 num ++ //后置自增 console.log(i++ + 1) //2 后置自增先运算 再++ // 先和1相加，先运算输出完毕后，i再自加 2. 二元运算符 需要两个操作数称为二元运算符\n3. 比较运算符 \u0026gt; \u0026lt; \u0026gt;= \u0026lt;= == //左右两边值是否相等 console.log(2==\u0026#39;2\u0026#39;) true === //左右两边是否类型和值都相等，强烈建议使用 console.log(2===\u0026#39;2\u0026#39;) false !== //左右两边是否不全等 字符串比较按照ASCII值，从左至右依次比较，如果第一位一样再比较第二位，以此类推\nconsole.log('a'\u0026lt;'b') //true\nNaN不等于任何值，包括它本身。涉及到 \u0026ldquo;NaN\u0026quot;都是false\n不同类型之间比较会发生隐式转换\n最终把数据隐士转换变成number类型再比较\n所以开发中，如果准确比较喜欢==或者!==\n比较运算符的结果返回true和false\n4. 逻辑运算符 符号 名称 特点 \u0026amp;\u0026amp; 逻辑与 一假则假 || 逻辑或 一真则真 ! 取反 真变假，假变真 5. 运算符优先级 优先级一致，从左至右运算\n优先级 运算符 顺序 1 小括号 （） 2 一元运算符 ++ \u0026ndash; ！ 3 算数运算符 先*/% 后+- 4 关系运算符 \u0026gt; \u0026gt;= \u0026lt; \u0026lt;= 5 相等运算符 == != === !== 6 逻辑运算符 先\u0026amp;\u0026amp;后|| 7 赋值运算符 = 8 逗号运算符 , 一元运算符的逻辑非优先级很高 逻辑与比逻辑或优先级 分支语句 1. 表达式 表达式是可以被求值的代码，JavaScript会计算出一个结果\n因为表达式可以被求值，所以它可以写在赋值语句的右侧num=3+4\n2. 语句 语句是一段可以执行的代码\nprompt() 可以弹出一个输入框，还有 if 语句 for循环语句\n而语句不一定有值，所以alert(), for, break等语句不能被用于赋值\nalert() 弹出对话框\nconsole.log() 控制台打印输出\n3. 程序三大流程控制语句 顺序结构：从上至下 分支结构（条件判断） 循环结构 4. 分支语句 种类：单分支、双分支、多分支\n只有一条分支会被执行\n使用方法\nif (condition 1){ ..... code block ..... } else if (condition 2){ ..... code block ..... } else if (condition 2){ ..... code block ..... } else { // 不满足条件执行的代码 ..... code block ..... } a. 括号内条件为true时，进入大括号执行代码\n除了 ==0== 之外的其余数字都是true 除了 ==\u0026rsquo; \u0026lsquo;== 所有的字符串都是true b. 小括号内的结果若不是布尔类型时，会发生隐式转换为布尔类型\nc. 如果大括号只有一个语句，大括号可以省略\nd. 先判断条件1，若满足条件1就执行代码1，其他不执行。若不满足则向下判断条件2，满足条件2 执行代码2，爱他不执行。若依然不满足继续向下判断，以此类推。若以上条件都不满足，执行else里面的代码。\n三元运算符 if 双分支的简洁版本\ncondition 满足 执行code1，不满足code2\ncondition ? code1 :code2 3\u0026gt;5 ? alert(\u0026#34;真的\u0026#34;):alert(\u0026#34;假的\u0026#34;) switch语句 Keopoints:\n找到小括号里面数据==全等==的case值，并执行里面对应的代码 若没有全等 =======的值，则执行defalut里面的代码 switch case语句一般用于等值判断，不适用于区间判断 switch case一般需要配合break关键词使用，没有break会造成case穿透 switch(数据){ case value1: //code break case value2: //code break case valueN: //code break default: //code break } Day3 循环语句 while循环 语法 while(condition){//执行条件 // code // 循环体 } 满足括号里面的条件true才会进入循环体执行代码 while大括号里代码执行完毕后不会跳出，而是继续回到小括号里面判断条件是否满足，若满足又执行大括号里的代码，然后再回到小括号里面判断条件，直到括号内条件不满足，跳出循环 三要素 变量起始值 终止条件（木有终止条件，循环会一直执行，造成死循环） 变量变化量（用自增或自减） let i = 1 while (i \u0026lt;= 3){ document.write(\u0026#39;循环三次\u0026#39;) } break \u0026amp; continue 循环里面遇到break直接退出循环 循环里面遇到continue，重新开始新的循环，原来continue之后的语句不再执行 3. for 循环 优点： 声明起始值、循环条件、变化值写到一起\n语法 for (变量起始值; 终止条件; 变量变化量){ //循环体 } 循环嵌套 双重for循环 for (outside_start; condition; change_value){ for(inside_start; condition; change_value){ //code body } } 4.无限循环： while(true) 使用break中断循环 for(;;) 使用break中断循环 5. while和for的区别 明确循环次数使用for 不明确循环次数，推荐使用while 数组 Array是一种按顺序保存数据的数据类型， 每个数据都有索引\n1. 声明语法 // 1. 字面量声明数组 let arr = [1,2,\u0026#39;pink\u0026#39;,\u0026#39;true\u0026#39;] // 2. 使用new Array构造函数声明 let arr = new Array(1,2,3,4) 2. 取值语法 let names = [\u0026#39;hams\u0026#39;,\u0026#39;jams\u0026#39;,\u0026#39;lily\u0026#39;,\u0026#39;lake\u0026#39;,\u0026#39;tom\u0026#39;] names[0] // hams names[1] // jams names.length //获得数组长度 3. 数组操作 增\narr.push(元素1,...,元素n) // 将一个或多个元素添加到数组末尾，并返回该数组的新长度[!important] arr.unshift(元素1,...,元素n) // 将一个或多个元素添加到数组开头，并返回该数组的新长度 删\narr.pop() // 从数组数组中删除最后一个元素，并返回该元素的值 arr.shift() //删除第一个元素 arr.splice(start, deleteCount) // 删除指定元素 // arr.splice(起始位置, 删除几个元素) // 如果没有指定deldeteCount,会默认从起始位置删除到数组最后 改 —\u0026gt; 数组[下标] = value\n查 —\u0026gt; 数组下标\nDay4 函数使用 函数声明 function funcName(){ console.log(\u0026#39;声明函数\u0026#39;) } 尽量小驼峰命名法 前缀应该为动词 命名建议：常用动词约定 动词 含义 can 判断是否可执行某个动作 has 判断是否含有某个值 is 判断是否为某个值 get 获取某个值 set 设置某个值 load 加载某些数据 函数调用 函数名( ) 函数与循环的不同：\n循环代码写完即执行，不能很方便控制执行位置 随时调用，随时执行，可重复掉用 函数传参 function funName(parameter...){ code body } function getSum(num1,num2){ document.write(num1+num2) } 参数列表 传入数据列表 声明这个函数需要传入几个数据 多个数据用逗号隔开 参数默认值 如果用户不给形参对应的实参，结果为==undefined== undefined + undefined == NaN 增加代码健壮性，用户不输入实参，可以给形参默认值 默认值只会在缺少实参参数时才会被执行 参数也可以是变量 function getSum(x = 0, y = 0){ document.write(x+y) } getSum() //结果是0，而不是NaN getSum(1,2) //结果是3 函数返回值 函数返回执行结果对整个程序的扩展性更高，可以让其他程序使用此结果\nKeypoints return 会立刻结束当前函数，后面的代码块不会执行 如果函数没有return, 则此函数默认返回值为undefined return多个值，使用return[max, min], 返回一个数组 function getMaxMinValue(arr = []) { let max = arr[0] let min = arr[0] for (let i = 1; i \u0026lt; arr.length; i++) { if (max \u0026lt; arr[i]) { max = arr[i] } } for (let i = 1; i \u0026lt; arr.length; i++) { if (min \u0026gt; arr[i]) { min = arr[i] } } return [max, min] } 函数细节 同一个作用域，两个相同名字的函数，后面的函数会覆盖前面的函数\nreturn 会结束函数，所以return后面不再有语句\nbreak VS return\nbreak -\u0026gt; 结束循环或switch\nreturn -\u0026gt; 结束函数\n参数不匹配\n实参比形参多，剩余实参不参与运算\n实参比形参少，1 + undefined == NaN\nfunction fn(a,b){ return a+b } fn(1,2,100) // return 3 fn(1) //NaN 作用域 变量名的有效范围称为作用域\n全局作用域 全局有效\n作用于所有代码执行环境（整个script标签内部或独立js文件）\n局部作用域 局部有效\n作用域函数内的代码环境，因为与函数有关系，也称为函数作用域\n全局变量 全局变量在任何区域都可以访问和修改\n如果函数内部，变量没有声明，直接赋值，也当作==全局变量==， 黑户一样的存在，不太规范。 函数的形参看作局部变量 局部变量 局部变量只能在当前函数内部访问修改\n变量的访问原则 只要是代码，就至少有一个作用域 写在函数内部的是局部作用域 如果函数中还有函数（嵌套），那么在这个作用域中又诞生一个作用域 ==访问原则：在能够访问到的情况下，先局部，局部没有再找全局== 作用域链：采取==就近原则==的方式查找变量的最终值 匿名函数 没有名字的函数，无法直接使用\n使用方式 函数表达式 将匿名函数赋值给一个变量，通过变量名称进行调用，我们将这个称为函数表达式\nlet fn = function(){ //code body condole.log(\u0026#39;hi\u0026#39;) } //调用方式 fn() //还是要加（） 函数表达式和具名函数的区别 具名函数的调用可以写在任何位置 匿名函数需要先声明函数表达式再使用 let btn = document.querySelector(\u0026#39;button\u0026#39;) btn.onclick = function(){ alert(\u0026#39;我是匿名函数\u0026#39;) } 立即执行函数 场景介绍：避免全局变量之间的污染\n// 方式一 (function(){})(); //必须加;不然函数不停止 //第二个()本质是调用函数 fn();可以加实参 (function(a+b){console.log(a+b)})(1,2); // 方式二 (function (){}()); (function(a+b){return a+b}(2,3)); //不需要调用，立刻执行 总结：\n立即执行函数主要作用是防止变量污染 立即执行函数无需调用，立即执行；多个立即执行函数用;隔开 逻辑中断 function fn(x,y){ x = x||0 y = y||0 //逻辑中断 } 逻辑运算符里的短路 短路：只存在于\u0026amp;\u0026amp;和||之间，当满足一定条件会让右边代码不执行\n符号 短路条件 \u0026amp;\u0026amp; 左边为false就短路 || 左边为true就短路 通过左边能得到整个式子的结果，没必要判断右边\n运算结果：\n无论\u0026amp;\u0026amp;还是||，运算结果都是最后被执行的表达式值，一般用在变量赋值\nconsole.log(false \u0026amp;\u0026amp; 3+5) //false let age = 18 console.log(false \u0026amp;\u0026amp; age++) //age还是18，因为左边为false，所以age++不能执行 console.log(age); console.log(11||age++) //age还是18,因为11判断为true,后面age++不执行 console.log(age) //如果表达式两侧都为真，则返回最后一个值 console.log(11\u0026amp;22) //return 22 转换为Boolean型 显式转换： ​\tBoolean( 数据 )\n​\t'', 0, undefined, null, false, NaN\n​\t转换为布尔值都是false，其余为true\nconsole.log(false \u0026amp;\u0026amp; 20) //false console.log(5\u0026lt;3 \u0026amp;\u0026amp; 20) // false console.log(undefined \u0026amp;\u0026amp; 20) //undefined console.log(null \u0026amp;\u0026amp; 20) // null console.log(0 \u0026amp;\u0026amp; 20) // 0 console.log(10 \u0026amp;\u0026amp; 20) //20 console.log(false || 20) //20 console.log(5\u0026lt;3 || 20) //20 console.log(undefined || 20) //20 console.log(null || 20) //20 console.log(0 || 20) //20 console.log(10 || 20) //10 隐式转换 有字符串的加法 \u0026quot;\u0026quot; + 1，结果是 “1”\n减法 - ，只能用于数字，会使空字符串\u0026quot;\u0026ldquo;转换为 0\nnull 经过数字转换后会变成 0\nundefined 经过数字转换后会变成NaN\nnull == undefined //true\nnull === undefined //false\nconsole.log(\u0026#39;\u0026#39;-1) //-1 console.log(\u0026#39;pink老师\u0026#39; -1) //NaN console.log(null + 1) // 1 console.log(undefined + 1) //NaN // undefined 无论 + - * / 都是NaN console.log(NaN + 1) //NaN // NaN做任何的操作都是NaN，NaN也不等于NaN Day5 对象(object) JavaScript里面的一种数据类型\n可以理解为一种无序的数据集合，数组是有序的数据集合\n用来描述某事物\nlet obj = { uname: \u0026#39;xx\u0026#39;, age: 18, gender: \u0026#39;女\u0026#39; } ###属性与方法\n声明方式 let objectName1 = {} let objectName2 = new Object() 属性 属性： 信息或特征 (名词) 尺寸、颜色、重量 方法：功能或行为 (动词) 打电话、发短信、玩游戏 let goods = { name: \u0026#39;小米10青春版\u0026#39;, num: 100012816024, weight: \u0026#39;0.55kg\u0026#39;, \u0026#39;current-address\u0026#39;: \u0026#39;中国大陆\u0026#39; } 属性都是成对出现，包括属性名和值，用英文 : 分隔 多个属性之间用英文 , 分隔 增删改查 查 console.log(goods.name) console.log(goods.price) //第二种方法 goods[\u0026#39;current-address\u0026#39;] 改 obj.gender = \u0026#39;男\u0026#39; 增 obj.hobby = \u0026#39;足球\u0026#39; //直接新增一个属性 删 delete obj.hobby 方法 方法由方法名和函数两部分构成，使用:分隔 多个属性之间使用,分隔 方法是依附在对象中的函数 方法名可以使用引号，一般情况省略，除非遇到特殊符号 可以添加实参和形参 let obj = { uname : \u0026#39;刘德华\u0026#39;, //匿名函数 song : function(){ console.log(\u0026#39;冰雨\u0026#39;) }, addNum : function(x,y){ console.log(x+y) } } obj.addNum(1,2) 后追加 obj.hobby = \u0026#39;足球\u0026#39; //注意后追加变成了 = 号 obj.move = function(){ //code body// } 遍历对象 ==for k in obj== 的索引是字符串，适合遍历对象 javascript的对象有点像字典， k-\u0026gt;key\nlet obj = { uname : \u0026#39;pink\u0026#39;, age : 18, gender: \u0026#39;男\u0026#39; } // 遍历对象 for (let k in obj){ console.log(k) //输出 \u0026#39;uname\u0026#39; console.log(obj[k]) } 一般不使用for k in obj这种方式遍历数组，主要是用来遍历对象 for in 语法中的 k是一个变量，在循环过程中依次代表对象的属性名 由于k是字符串变量，所以需要使用 [ ] 语法解析 ==k==是获得对象的属性名，==obj [k]== 是获得属性值 内置对象 JavaScript内部提供的对象，包含各种属性和方法给开发者调用\nconsole.log() document.write() Math 提供了一系列的数学运算的方法\n包含方法 random-\u0026gt; 生成0-1之间的随机数 （包0不包1）\nceil -\u0026gt; 向上取整\nfloor -\u0026gt; 向下取整\n有点像parseInt( )\nround -\u0026gt; 四舍五入\nmax -\u0026gt; 找最大数\nmin-\u0026gt; 找最小数\npow-\u0026gt; 幂运算\nabs-\u0026gt; 绝对值\nMath.random() // 向下取整 Math.floor(Math.random()*(10+1)) //随机抽取数组 let arr = [\u0026#39;red\u0026#39;,\u0026#39;green\u0026#39;,\u0026#39;blue\u0026#39;] let random = Math.floor(Math.random()*arr.length) //生成N-M之间的随机数 Math.floor(Math.random()*(M-N+1))+N //如何生成5-10之间的随机数 Math.floor(Math.random()*(5+1))+5 //抽奖游戏，抽中的人在列表中删除 let name_arr = [\u0026#39;赵云\u0026#39;, \u0026#39;黄忠\u0026#39;, \u0026#39;关羽\u0026#39;, \u0026#39;张飞\u0026#39;] while (name_arr.length \u0026gt; 0) { let random_index = Math.floor(Math.random() * name_arr.length) document.write(name_arr.splice(random_index, 1)) } //数组删除数据方式 splice(起始位置,删除几个元素) 数据类型 基本数据类型 又称为值类型，在存储变量中，存储的值本身\nstring, number, boolean, undefined, null 引用数据类型 复杂数据类型，在存储变量时是地址（引用）\n通过new关键创造的对象 Object, Array, Data 栈堆 ![image-20240227220622098](/Users/jingyiwu/Library/Application Support/typora-user-images/image-20240227220622098.png)\n![image-20240227220658528](/Users/jingyiwu/Library/Application Support/typora-user-images/image-20240227220658528.png)\n","permalink":"https://jingyiwu-codespace.github.io/zh/posts/tech/javascript_note/","summary":"开始学习JavaScript!! 课程来自于 Udemy+Bilibili","title":"学习: JavaScript 基础篇"},{"content":"在终端中干掉进程 1. 检查有没有僵尸进程 在终端中使用👇的语句.\nps aux | grep 'Z'\n2. 检查端口的使用情况 在终端中使用👇的语句.\nsudo lsof -i :60001\n60001 是端口名称, 输入一下语句之后，就能看到进程的ID了. (方便直接干掉它)\n3. 关键一步：干掉进程 kill [PID] kill -9 [PID]\n最后一个 -9 是强制停止\n4. 再检查一遍端口的使用情况 我遇到的问题是我的计算机总是有两个进程，一个来自 Java，一个来自 sudo。所以我需要杀死 sudo，因为 cooja 在 Java 中运行. 如果kill进程失败了, 尝试使用sudo kill [PID]\n","permalink":"https://jingyiwu-codespace.github.io/zh/posts/tech/cooja_kill_process/","summary":"每次运行Cooja的端口监听，显示资源繁忙，可能是端口已经被占用，只要给其中一个进程干掉就好.","title":"解决: Cooja 端口显示资源繁忙"},{"content":"路线: 塞维利亚 [Alsa城际大巴] -\u0026gt; 格拉纳达 [茯苓航空] -\u0026gt; 巴塞罗那 景点 \u0026gt; Day 1 塞维利亚 新印第安博物馆 免门票 塞维利亚皇宫 西班牙广场 \u0026gt; Day 2 塞维利亚 塞维利亚大教堂 25岁以下欧盟学生可以买学生票，查了我的学生证，还有我的生日 人山人海\n\u0026gt; Day 3 格拉纳达 阿布拉罕宫 风格大不相同，可以去康康，挺漂亮的（不喜欢建筑的可以不去，还是有点折腾）\n\u0026gt; Day 4 巴塞罗那 看海看海看海!! 巴塞罗那忒忒忒忒忒舒服了!!! \u0026gt; Day 5 巴塞罗那 看了高迪三件套 圣家堂 圣家堂里面是挺漂亮的，但是我对教堂兴趣不大）\n","permalink":"https://jingyiwu-codespace.github.io/zh/posts/life/tripspain/","summary":"路线：塞维利亚 -\u0026gt; 格拉纳达 -\u0026gt; 巴塞罗那","title":"🇪🇸 去西班牙旅游 !!"},{"content":" 成为更好的人｜｜慢慢前进\n啊喂!! 什么情况只能听30s!!! 插入一段无广b站食用!!! \u003c!DOCTYPE HTML\u003e ","permalink":"https://jingyiwu-codespace.github.io/zh/posts/life/first/","summary":"新空间 新起点","title":"ε≡٩(๑\u003e₃\u003c)۶"},{"content":" class Me: def __init__(self): self.prefer_name = \u0026#34;小吴\u0026#34; self.born_year = 1999 self.MBTI = \u0026#34;ISFJ\u0026#34; self.constellation = \u0026#34;摩羯\u0026#34; self.curr_location = \u0026#34;布鲁塞尔｜ 比利时\u0026#34; self.grad_school = \u0026#34;香港浸会大学\u0026#34; self.undergrad_school = \u0026#34;东北吃饭大学\u0026#34; ","permalink":"https://jingyiwu-codespace.github.io/zh/about/","summary":"class Me: def __init__(self): self.prefer_name = \u0026#34;小吴\u0026#34; self.born_year = 1999 self.MBTI = \u0026#34;ISFJ\u0026#34; self.constellation = \u0026#34;摩羯\u0026#34; self.curr_location = \u0026#34;布鲁塞尔｜ 比利时\u0026#34; self.grad_school = \u0026#34;香港浸会大","title":"关于我"},{"content":"\u003c!DOCTYPE html\u003e Title ","permalink":"https://jingyiwu-codespace.github.io/zh/resume/","summary":"\u003c!DOCTYPE html\u003e Title","title":"简历"}]